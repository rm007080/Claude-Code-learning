---
created: 2025-11-03
tags:
  - Perplexity
aliases:
related:
---

# Claude Codeのサブエージェント機能：完全ガイド

## 目次
1. [トークン消費メカニズム](#トークン消費メカニズム)
2. [サブエージェントの定義](#サブエージェントの定義)
3. [手動ファイル依頼とサブエージェントの違い](#手動ファイル依頼とサブエージェントの違い)
4. [実装方法](#実装方法)
5. [活用シーン](#活用シーン)
6. [注意点と制限事項](#注意点と制限事項)

---

## トークン消費メカニズム

### 重要：誤解しやすいポイント

**⚠️ よくある誤り**
- サブエージェントは「独立したトークン予算を持つ」❌
- サブエージェントのトークン消費は「メインセッションに影響しない」❌

**✅ 正しい理解**
- サブエージェントはメインセッション**と同じトークンプール**から消費
- 5時間のローリング制限は**全エージェント共有**
- トークン予算は共有、コンテキスト履歴のみ分離

### トークン予算構造

```
ユーザーの総トークン予算（例：Pro planの場合）
└── 5時間ローリング制限
    ├── メインセッション
    ├── サブエージェント1
    ├── サブエージェント2
    └── サブエージェント3
    
すべてが同じプールから消費される
```

### 並列実行とトークン消費速度

**実例：300ファイル以上の更新タスク**

| 実行方法 | 処理時間 | トークン消費速度 |
|---|---|---|
| 順序実行（単一エージェント） | 約30分 | 標準速度 |
| 並列実行（複数サブエージェント） | 約15分 | **2倍の速度** |

**重要**：並列実行で「速度が2倍」になるということは、「トークン消費も2倍の速度」という意味

### コンテキストウィンドウの分離

```
各サブエージェント = 200,000トークンの独立したコンテキスト窓

これは「トークン予算を持つ」という意味ではなく、
「過去の作業履歴が混ざらない」という意味
```

---

## サブエージェントの定義

### サブエージェントとは何か

**定義**：特定のタスク領域に特化した、独立したシステムプロンプトを持つAIアシスタント

**構成要素**
- 独立したシステムプロンプト（指示セット）
- 200,000トークンの独立したコンテキストウィンドウ
- カスタマイズされたツール権限
- 特定の専門領域への最適化

### 実装ファイル構造

```markdown
# .claude/agents/code-reviewer.md

---
name: code-reviewer
description: コード品質とセキュリティのレビューに特化
tools: Read, Grep, Glob, Bash
model: inherit
---

あなたはシニアコードレビューアーです。

責務：
1. コード品質の確認
2. セキュリティの脆弱性検出
3. パフォーマンスの問題認識
4. 保守性の評価

チェックリスト：
- [ ] 型安全性の確認
- [ ] エラーハンドリング
- [ ] テストカバレッジ
- [ ] ドキュメント完全性
```

**配置場所**：`.claude/agents/[agent-name].md`

### 作成方法

**方法1：CLIコマンド**
```
/agents
```

**方法2：手動作成**
1. `.claude/agents/`フォルダを作成
2. Markdownファイルを作成
3. frontmatter（YAML）を設定
4. プロンプトを記述

---

## 手動ファイル依頼とサブエージェントの違い

### 実行コンテキストの本質的な違い

#### 手動ファイル依頼のプロセス

```
あなた：「このファイルの指示に従ってください」
    ↓
メインセッションのコンテキストに指示ファイルが読み込まれる
    ↓
指示ファイル + 過去の会話履歴 + 新作業
    ↓
すべてが同じコンテキスト空間に蓄積
```

**結果**：アテンション拡散により精度低下

#### サブエージェント呼び出しのプロセス

```
あなた：「code-reviewerサブエージェントを使用してください」
    ↓
独立した実行環境が起動
    ↓
サブエージェント独自のシステムプロンプト + タスク
    ↓
メインセッション履歴は一切見ない
    ↓
結果のみがメインセッションに返却
```

**結果**：コンテキスト分離により精度向上

### 比較表

| 項目 | 手動ファイル依頼 | サブエージェント |
|---|---|---|
| **コンテキスト統合** | メインセッションに統合 | 完全に分離 |
| **自動起動** | 毎回明示的な指示が必要 | 自動認識・自動委任可能 |
| **セットアップ** | シンプル | 初期セットアップ必要 |
| **再利用性** | 低い（毎プロジェクトで説明） | 高い（一度定義すれば再利用） |
| **長期トークン効率** | 低い（繰り返し読み込み） | 高い（メインセッション外） |
| **透明性** | 高い（全過程が見える） | 中程度（結果のみ可視） |
| **複雑な指示の処理** | 混乱しやすい | 専門的・正確 |
| **大規模プロジェクト** | コンテキスト枯渇リスク | 適切 |

### アテンションの拡散問題（技術的背景）

**Transformerアーキテクチャの特性**

自己注視（self-attention）はコンテキスト全体を参照するため：

**手動ファイル依頼の場合**
```
コンテキストサイズ：12,000トークン
├─ 過去のコード修正履歴：5,000トークン
├─ 現在のタスク：2,000トークン
├─ 指示ファイル：3,000トークン
└─ 新しい作業：2,000トークン

→ アテンションが分散
→ 指示が過去のタスク情報に埋もれる
→ 精度低下
```

**サブエージェント実行の場合**
```
コンテキストサイズ：5,000トークン
├─ 指示ファイル内容：3,000トークン
└─ 与えられたタスク：2,000トークン

→ アテンションが集中
→ 指示に完全に集中
→ 精度向上
```

---

## 実装方法

### ステップ1：サブエージェントファイルの作成

```markdown
# .claude/agents/task-decomposer.md

---
name: task-decomposer
description: 複雑なタスクを実行可能なステップに分解する専門家
tools: Read, Grep, Glob
model: inherit
---

あなたは経験豊富なプロジェクトマネージャーです。

目標：複雑なタスクを、実行順序を含む小さな段階的なタスクに分解

原則：
1. 各ステップは独立して実行可能
2. 依存関係を明確に記述
3. 実装には約2-4時間を目安
4. 各ステップに必要なリソースを記載

出力形式：
## タスク分解結果
- [ ] ステップ1：〇〇
- [ ] ステップ2：〇〇（ステップ1完了後）
```

### ステップ2：複数サブエージェント間の連携

```markdown
# .claude/agents/task-executor.md

---
name: task-executor
description: 分解されたタスクを実行する実装専門家
tools: Read, Write, Edit, Bash
model: inherit
---

あなたはシニア開発者です。

役割：task-decomposerが分解したタスクを正確に実行

プロセス：
1. タスク一覧を確認
2. 依存関係を確認
3. ステップバイステップで実装
4. 各ステップ完了後、次のステップに進む
```

### ステップ3：呼び出し方法

**明示的な呼び出し**
```
@task-decomposer を使用してこのフィーチャーを実装可能なタスクに分解してください
```

**自動委任**
- Claude Codeが自動的に認識し、適切なサブエージェントに委任
- `description`フィールドが判断基準になる

---

## 活用シーン

### シーン1：大規模プロジェクトの品質管理

**問題**：複数のチェック項目（Lint、型チェック、テスト、依存関係チェック）をメインセッションで処理するとコンテキスト枯渇

**解決策**：複数の専門サブエージェントを運用

```
linter-agent
├─ Lintルール読み込み
├─ コード走査
└─ 問題報告

type-checker-agent
├─ 型チェックルール読み込み
├─ 型検証
└─ 型エラー報告

test-runner-agent
├─ テストルール読み込み
├─ テスト実行
└─ テスト失敗分析

dependency-checker-agent
├─ 依存関係チェックルール読み込み
├─ 循環依存検出
└─ 依存関係リスク報告

メインセッション：結果統合・最終判断
```

**効果**
- コンテキスト枯渇なし
- 各エージェントが専門領域に集中
- 品質向上
- 並列処理による高速化

### シーン2：異なる専門領域の並列作業

**実例**：マイクロサービスアーキテクチャのログ分析

```
service-a-analyzer
├─ サービスAのログを分析
└─ パフォーマンス問題検出

service-b-analyzer
├─ サービスBのログを分析
└─ パフォーマンス問題検出

service-c-analyzer
├─ サービスCのログを分析
└─ パフォーマンス問題検出

3つのサブエージェントが同時実行
```

### シーン3：段階的ワークフロー

```
1. task-decomposer
   ↓
   複雑な要件を実行可能なタスクに分解

2. task-executor
   ↓
   分解されたタスクを順序実行

3. quality-checker
   ↓
   完了したタスクの品質確認

4. フィードバックループ
   ↓
   必要に応じて修正
```

### 典型的なサブエージェント例

| サブエージェント | 役割 | ツール権限 | 用途 |
|---|---|---|---|
| code-reviewer | コード品質・セキュリティレビュー | Read, Grep, Glob, Bash | ピアレビュー自動化 |
| debugger | エラーとテスト失敗の原因追及 | Read, Edit, Bash, Grep | バグ修正支援 |
| test-runner | テスト実行と失敗原因分析 | Bash, Read, Edit | テスト自動化 |
| data-scientist | SQL/BigQuery分析 | Bash, Read, Write | データ分析 |
| security-auditor | セキュリティ脆弱性検査 | Read, Grep, Glob | セキュリティ監査 |
| documentation-writer | ドキュメント生成 | Write, Edit, Read | ドキュメント自動化 |

---

## 注意点と制限事項

### ⚠️ トークン予算に関する重要警告

**並列実行時の高速トークン消費**

複数のサブエージェントを同時実行すると、トークン消費速度は劇的に加速します。

```
例：3つのサブエージェントが同時実行
→ トークン消費速度が3倍近くになる可能性
→ Pro plan でも5時間で予算完全消費の危険
```

**対策**
- 大規模タスクは段階的に実行
- ガード機構を実装（トークン残量チェック）
- Max planの利用を検討

### サブエージェント実行時の遅延

**ツール実行の遅延**
- 各サブエージェント呼び出しごとに、新しいコンテキストから始まる
- 必要なコンテキストを再度読み込む必要がある
- わずかな遅延が発生

**最適化方法**
- 頻繁に参照するファイルはスキルとして共有
- 不要なツール権限は制限

### 透明性とデバッグ

**デメリット**
- デフォルトではサブエージェント内の推論過程が見えない
- ブラックボックス化しやすい

**解決策**
- `Ctrl+O`でサブエージェント内の思考プロセスを確認
- 必要に応じてメインセッションで詳細情報をリクエスト

### ツール権限の制限

**セキュリティと効率**

サブエージェントには必要最小限のツール権限のみを付与：

```markdown
# 読み取り専門エージェント
tools: Read, Grep, Glob

# 変更権限を持つエージェント
tools: Read, Write, Edit, Bash

# テスト実行専門
tools: Bash, Read
```

---

## チェックリスト：サブエージェント導入時の判断基準

### サブエージェント導入が**向いている**場合
- [ ] プロジェクトが大規模（複数のマイクロサービス/モジュール）
- [ ] 複数の専門領域が必要（フロントエンド、バックエンド、QA）
- [ ] 長期運用で何度も同じ指示を繰り返す
- [ ] コンテキスト枯渇の問題が発生している
- [ ] チーム全体で統一された手順を共有したい

### 手動ファイル依頼で**十分**な場合
- [ ] 小〜中規模プロジェクト
- [ ] 一度限りのタスク
- [ ] シンプルな指示
- [ ] 完全な透明性が必要
- [ ] セットアップの負担を避けたい

---

## まとめ：状況別の対応方針

### Q：トークン消費が心配
**A：**
- 並列実行を避ける（段階的実行を選択）
- Max planを検討
- ガード機構を実装
- 不要なサブエージェントは定義しない

### Q：コンテキスト枯渇が発生している
**A：**
- 関連タスクごとにサブエージェント化
- 複数のサブエージェントで役割分離
- 各サブエージェントにスキルを共有

### Q：本当にサブエージェントが必要か判断できない
**A：**
1. 現在、単一セッションでコンテキスト枯渇が発生しているか？
   - YES → サブエージェント導入を検討
   - NO → 手動ファイル依頼で十分

2. 同じ指示を何度も繰り返しているか？
   - YES → サブエージェント化で効率向上
   - NO → 手動ファイル依頼で十分

3. 複数の専門領域があるか？
   - YES → サブエージェント化で役割明確化
   - NO → 手動ファイル依頼で十分

### Q：手動ファイル依頼とサブエージェント、どちらを使うべき？
**A：表を参照してください**（比較表参照）

---

## 参考：実装例（実際のプロジェクト構成）

```
.claude/
├── agents/
│   ├── task-decomposer.md
│   ├── task-executor.md
│   ├── quality-checker.md
│   └── code-reviewer.md
├── skills/
│   ├── project-guidelines.md
│   ├── coding-standards.md
│   └── testing-requirements.md
├── commands/
│   ├── run-tests.sh
│   └── lint-check.sh
└── CLAUDE.md（グローバル指示）
```

**スキル共有の例**

```markdown
# .claude/skills/coding-standards.md

## コーディング規約

すべてのサブエージェントが参照：

```yaml
<!-- SKILL: coding-standards -->
```

このスキルを各サブエージェントで参照することで、
重複した指示を避け、トークン効率を向上させる
```

---

## 変更ログ

- **2025-11-03**：初版作成
  - トークン消費メカニズムの正確な説明
  - 手動ファイル依頼との違いを技術的に解説
  - 実装方法と活用シーンを網羅
