# 02. カスタムコマンドの作成

## この章で学ぶこと

よく使う指示や複雑な手順を短いコマンドで呼び出せる「カスタムコマンド」の作成方法を学びます。$ARGUMENTSの活用、実践的なテンプレート、チームでの共有方法を習得します。

## カスタムコマンドとは？

カスタムコマンドは、よく使う指示や複雑な手順を短いコマンドで実行できる機能です。スマートフォンの「ショートカット」に似ています。

### メリット

1. **作業の標準化**
   - チーム全体で同じ手順を実行
   - ミスが減る

2. **時間の節約**
   - 長い指示を毎回書かなくて良い
   - `/コマンド名` だけで実行

3. **複雑な処理の簡略化**
   - 複数ステップをまとめて実行
   - 条件分岐も可能

4. **ナレッジの共有**
   - ベストプラクティスを共有
   - 新メンバーのオンボーディング

## カスタムコマンドの種類

### 1. プロジェクトコマンド（チーム共有）

**保存場所**: `.claude/commands/`

**用途**:
- チーム全体で使用
- Gitでバージョン管理
- プロジェクト固有の手順

**呼び出し方**:
```bash
> /project:コマンド名
# または
> /コマンド名
```

### 2. 個人コマンド（自分専用）

**保存場所**: `~/.claude/commands/`

**用途**:
- 個人の作業スタイル
- 全プロジェクトで共通
- 個人的なテンプレート

**呼び出し方**:
```bash
> /user:コマンド名
# または
> /コマンド名
```

## カスタムコマンドの作成方法

### ステップ1: ディレクトリを作成

```bash
# プロジェクトコマンド用
mkdir -p .claude/commands

# 個人コマンド用
mkdir -p ~/.claude/commands
```

### ステップ2: Markdownファイルを作成

ファイル名がコマンド名になります。

```bash
# 例: /improve コマンドを作成
touch .claude/commands/improve.md

# または
code .claude/commands/improve.md
```

### ステップ3: コマンド内容を記述

```markdown
このプロジェクトの主要なファイルを確認し、改善点を3つ教えてください。

特に以下の観点で確認してください:
1. パフォーマンス
2. 可読性
3. 保守性
```

### ステップ4: 使用する

```bash
> /improve
```

## $ARGUMENTSの活用

`$ARGUMENTS` を使うことで、コマンド実行時に値を渡せます。

### 基本的な使い方

**コマンドファイル**: `.claude/commands/review-file.md`
```markdown
$ARGUMENTS のコードをレビューしてください。

確認項目:
- バグの可能性
- パフォーマンスの問題
- セキュリティの懸念
- コードの可読性

問題があれば具体的な修正案も提示してください。
```

**使用方法**:
```bash
> /review-file src/components/UserProfile.tsx
```

`$ARGUMENTS` が `src/components/UserProfile.tsx` に置き換わります。

### 複数の引数を渡す

**コマンドファイル**: `.claude/commands/compare.md`
```markdown
以下のファイルを比較して違いを説明してください:
$ARGUMENTS

共通点と相違点を整理して教えてください。
```

**使用方法**:
```bash
> /compare src/old-version.ts src/new-version.ts
```

## 実践的なカスタムコマンド集

### 1. コードレビューコマンド

**ファイル**: `.claude/commands/code-review.md`
```markdown
$ARGUMENTS のコードを詳細にレビューしてください。

## レビュー観点
- [ ] セキュリティ（XSS、SQLインジェクション、認証・認可）
- [ ] パフォーマンス（N+1問題、不要な再レンダリング）
- [ ] エラーハンドリング（try-catch、エラーメッセージ）
- [ ] 型安全性（TypeScript strict mode）
- [ ] テストカバレッジ（エッジケースのテスト）
- [ ] コーディング規約（このプロジェクトの規約に従っているか）

## 出力形式
### Good Parts（良い点）
[良い点をリストアップ]

### Issues（改善すべき点）
[問題点と修正案]

### Suggestions（提案）
[さらなる改善提案]
```

**使用例**:
```bash
> /code-review src/api/auth.ts
```

### 2. GitHubイシュー対応コマンド

**ファイル**: `.claude/commands/fix-issue.md`
```markdown
GitHub Issue #$ARGUMENTS を確認して、以下の手順で対応してください:

1. イシューの内容を確認
2. 関連ファイルを特定
3. 修正を実装
4. テストを実行
5. 修正内容をgit addしてコミット

コミットメッセージのフォーマット:
fix: #$ARGUMENTS [イシューのタイトル]
```

**使用例**:
```bash
> /fix-issue 123
```

### 3. テスト作成コマンド

**ファイル**: `.claude/commands/write-test.md`
```markdown
$ARGUMENTS のテストを作成してください。

## テスト要件
- テストフレームワーク: Jest
- カバレッジ: 80%以上
- テストケース:
  - 正常系（成功ケース）
  - 異常系（エラーケース）
  - エッジケース（境界値）

## テストファイル名
元ファイルと同じディレクトリに、`[ファイル名].test.ts` を作成

## テストの構造
```typescript
describe('[コンポーネント/関数名]', () => {
  describe('[機能1]', () => {
    it('[正常系]', () => {});
    it('[異常系]', () => {});
  });

  describe('[機能2]', () => {
    it('[正常系]', () => {});
    it('[異常系]', () => {});
  });
});
```
```

**使用例**:
```bash
> /write-test src/utils/validation.ts
```

### 4. リファクタリングコマンド

**ファイル**: `.claude/commands/refactor.md`
```markdown
$ARGUMENTS をリファクタリングしてください。

## リファクタリング方針
1. 関数は単一責任の原則に従う
2. 1つの関数は50行以内
3. マジックナンバーを避ける
4. 早期リターンを使う
5. 複雑な条件式は関数に抽出

## 制約
- 既存の動作を変えない
- テストは全て通ること
- TypeScript strict モードでエラーが出ないこと

## 手順
1. 現在の問題点を特定
2. リファクタリング計画を立てる
3. 段階的に実装
4. 各段階でテストを実行
5. 完了後にコミット

コミットメッセージ: refactor: [ファイル名] [改善内容]
```

**使用例**:
```bash
> /refactor src/components/Dashboard.tsx
```

### 5. デプロイ前チェックコマンド

**ファイル**: `.claude/commands/deploy-check.md`
```markdown
デプロイ前のチェックリストを実行してください。

## チェック項目

### 1. テスト
- [ ] ユニットテストが全て通る
- [ ] E2Eテストが全て通る
- [ ] テストカバレッジが80%以上

コマンド:
```bash
npm test
npm run test:e2e
npm run test:coverage
```

### 2. ビルド
- [ ] 本番ビルドが成功する
- [ ] TypeScript型チェックが通る
- [ ] Lintエラーがない

コマンド:
```bash
npm run build
npm run typecheck
npm run lint
```

### 3. セキュリティ
- [ ] 依存関係の脆弱性チェック
- [ ] .envファイルがコミットされていない
- [ ] APIキーがハードコードされていない

コマンド:
```bash
npm audit
git status
```

### 4. パフォーマンス
- [ ] バンドルサイズが3MB以下
- [ ] Lighthouseスコア90以上

すべてのチェックが完了したら、デプロイ可能と報告してください。
問題があれば、具体的な修正方法を提案してください。
```

**使用例**:
```bash
> /deploy-check
```

### 6. APIエンドポイント作成コマンド

**ファイル**: `.claude/commands/create-api.md`
```markdown
$ARGUMENTS の APIエンドポイントを作成してください。

## ファイル構成
- src/app/api/$ARGUMENTS/route.ts: エンドポイント
- src/lib/api/$ARGUMENTS.ts: ビジネスロジック
- src/types/api/$ARGUMENTS.ts: 型定義

## 実装要件

### 型定義
- リクエストボディの型
- レスポンスの型
- エラーレスポンスの型

### バリデーション
- Zodスキーマでバリデーション
- 適切なエラーメッセージ

### エラーハンドリング
- try-catchで例外処理
- 適切なHTTPステータスコード
- 統一されたエラーレスポンス形式

### セキュリティ
- 認証チェック
- レート制限
- 入力値のサニタイズ

### テスト
- 成功ケース
- 各種エラーケース

## 実装順序
1. 型定義
2. バリデーションスキーマ
3. ビジネスロジック
4. エンドポイント実装
5. テスト作成
```

**使用例**:
```bash
> /create-api users/profile
```

### 7. コンポーネント作成コマンド

**ファイル**: `.claude/commands/create-component.md`
```markdown
$ARGUMENTS コンポーネントを作成してください。

## ファイル構成
- src/components/$ARGUMENTS.tsx: コンポーネント
- src/components/$ARGUMENTS.test.tsx: テスト
- src/components/$ARGUMENTS.stories.tsx: Storybook

## コンポーネント要件

### 型定義
```typescript
export interface [コンポーネント名]Props {
  // propsの型定義
}
```

### 実装規約
- Server Component を優先（必要な場合のみ Client Component）
- 100行以内に抑える
- propsは interface で定義
- export は名前付きエクスポート

### スタイリング
- Tailwind CSS を使用
- レスポンシブデザイン必須（mobile-first）
- ダークモード対応も考慮

### アクセシビリティ
- 適切なARIAラベル
- キーボード操作対応
- スクリーンリーダー対応

### テスト
- レンダリングテスト
- ユーザー操作のテスト
- エッジケースのテスト

## 実装順序
1. 型定義とprops
2. コンポーネント本体
3. スタイリング
4. テスト
5. Storybook
```

**使用例**:
```bash
> /create-component UserProfile
```

## チーム向けカスタムコマンド

### プロジェクトのコマンドを整理

**ディレクトリ構造**:
```
.claude/
└── commands/
    ├── code-review.md       # コードレビュー
    ├── fix-issue.md         # イシュー対応
    ├── write-test.md        # テスト作成
    ├── refactor.md          # リファクタリング
    ├── deploy-check.md      # デプロイチェック
    ├── create-api.md        # API作成
    └── create-component.md  # コンポーネント作成
```

### README.mdでコマンドを文書化

**ファイル**: `.claude/commands/README.md`
```markdown
# カスタムコマンド一覧

## コードレビュー
```bash
/code-review [ファイルパス]
```
指定したファイルを詳細にレビューします。

## イシュー対応
```bash
/fix-issue [イシュー番号]
```
GitHubイシューの内容を確認し、修正を実装します。

## テスト作成
```bash
/write-test [ファイルパス]
```
指定したファイルのテストを作成します。

## リファクタリング
```bash
/refactor [ファイルパス]
```
指定したファイルをリファクタリングします。

## デプロイチェック
```bash
/deploy-check
```
デプロイ前のチェックリストを実行します。

## API作成
```bash
/create-api [エンドポイントパス]
```
新しいAPIエンドポイントを作成します。

## コンポーネント作成
```bash
/create-component [コンポーネント名]
```
新しいReactコンポーネントを作成します。
```

## 高度なテクニック

### 条件分岐を含むコマンド

**ファイル**: `.claude/commands/smart-test.md`
```markdown
$ARGUMENTS のテストを作成してください。

## ファイルの種類を判定
- ファイル名に "component" または拡張子が .tsx の場合
  → Reactコンポーネントのテストを作成
- ファイル名に "api" または "route" が含まれる場合
  → APIエンドポイントのテストを作成
- それ以外
  → ユニットテストを作成

## ファイルの種類に応じて適切なテストを作成してください
```

### 複数ステップのコマンド

**ファイル**: `.claude/commands/feature-complete.md`
```markdown
$ARGUMENTS 機能を完全に仕上げてください。

## ステップ1: 実装の確認
- コードの品質チェック
- TypeScript型チェック
- Lintエラーチェック

## ステップ2: テストの確認
- ユニットテストの実行
- テストカバレッジの確認（80%以上）
- 不足しているテストケースの特定

## ステップ3: ドキュメントの確認
- JSDocコメントの確認
- README.mdの更新
- 必要に応じてCLAUDE.mdの更新

## ステップ4: Git操作
- git statusで変更確認
- git diffで差分確認
- 適切なコミットメッセージの提案

## ステップ5: 報告
- 完了した項目
- 残課題（あれば）
- 次のステップの提案
```

## トラブルシューティング

### 問題1: コマンドが認識されない

**症状**: `/コマンド名` が動作しない

**原因**:
- ファイル名のタイプミス
- ファイルの場所が間違っている

**解決策**:
```bash
# ファイルの存在確認
ls -la .claude/commands/
ls -la ~/.claude/commands/

# Claude Codeを再起動
> /exit
claude
```

### 問題2: $ARGUMENTSが展開されない

**症状**: `$ARGUMENTS` がそのまま表示される

**原因**: コマンド実行時に引数を渡していない

**解決策**:
```bash
# ✅ 引数を渡す
> /review-file src/components/Button.tsx

# ❌ 引数なし
> /review-file
```

### 問題3: コマンドが更新されない

**症状**: ファイルを編集しても反映されない

**解決策**:
```bash
# Claude Codeを再起動
> /exit
claude
```

## ベストプラクティス

### 1. コマンド名は明確に

```bash
# ✅ 良い例
/code-review
/fix-issue
/write-test

# ❌ 悪い例
/cr
/fix
/test
```

### 2. コマンドの先頭にコメントを追加

```markdown
# このコマンドの説明
# 使用例: /command-name [引数]

コマンドの本文...
```

### 3. よく使うコマンドは短く

```bash
# プロジェクトコマンド（チーム共有）
/review      # 詳細なコードレビュー
/quick-review  # 簡易レビュー

# 個人コマンド
/r           # 自分用の簡易レビュー
```

### 4. コマンドをバージョン管理

```bash
# .gitignore に個人コマンドを追加
~/.claude/commands/

# プロジェクトコマンドはGitで管理
.claude/commands/
```

## まとめ

### カスタムコマンドの価値

1. **効率化**: 長い指示を短縮
2. **標準化**: チーム全体で統一
3. **品質向上**: ベストプラクティスの共有
4. **オンボーディング**: 新メンバーの学習を支援

### 作成のステップ

1. よく使う指示を特定
2. Markdownファイルを作成
3. $ARGUMENTSで柔軟に
4. チームで共有

### 次のステップ

次の章では、Hooksの活用方法を学びます。タスク完了時の自動処理、通知の送信など、さらに高度なカスタマイズを習得します。
