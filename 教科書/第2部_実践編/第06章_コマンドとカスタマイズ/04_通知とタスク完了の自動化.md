# 04. 通知とタスク完了の自動化

## この章で学ぶこと

タスク完了通知の設定、reviewitツールの活用、カスタム通知スクリプトの作成など、Claude Codeのタスク完了時の自動化を完全にマスターします。

## なぜ通知が重要か？

### 問題: 長時間タスクの監視

Claude Codeに長時間かかるタスク（ビルド、テスト、大規模リファクタリング等）を依頼すると:
- 完了のタイミングがわからない
- 別の作業をしていると気づかない
- 時間を無駄にする可能性がある

### 解決: 自動通知

タスク完了時に自動的に通知することで:
- すぐに次の作業に移れる
- 効率的な時間の使い方
- マルチタスクが可能

## 通知方法の種類

### 1. Terminal Bell（標準機能）

**設定方法**:
```json
{
  "preferredNotifChannel": "terminal_bell"
}
```

**メリット**:
- 設定が簡単
- 追加ツール不要

**デメリット**:
- 音が小さい
- 環境によって動作しない
- カスタマイズできない

### 2. 音声通知（macOS/Linux）

**設定方法**:
```json
{
  "hooks": {
    "Stop": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "say \"Task completed!\""
          }
        ]
      }
    ]
  }
}
```

**メリット**:
- 確実に気づける
- メッセージをカスタマイズ可能

**デメリット**:
- 環境依存（macOS/Linux）
- 周囲の環境によっては不適切

### 3. デスクトップ通知

**macOS**:
```json
{
  "hooks": {
    "Stop": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "osascript -e 'display notification \"Task completed\" with title \"Claude Code\"'"
          }
        ]
      }
    ]
  }
}
```

**Linux (notify-send)**:
```json
{
  "hooks": {
    "Stop": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "notify-send 'Claude Code' 'Task completed'"
          }
        ]
      }
    ]
  }
}
```

**Windows (PowerShell)**:
```json
{
  "hooks": {
    "Stop": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "powershell -Command \"[System.Windows.Forms.MessageBox]::Show('Task completed', 'Claude Code')\""
          }
        ]
      }
    ]
  }
}
```

**メリット**:
- 視覚的に確認できる
- 通知センターに履歴が残る

**デメリット**:
- OS依存の設定が必要

## reviewitツールの活用

### reviewitとは？

reviewitは、Git差分を視覚的にレビューできるツールです。Claude Codeが生成したコードを効率的にレビューできます。

**特徴**:
- Webベースのレビューインターフェース
- 行ごとのコメント機能
- 変更の承認/却下
- コメントのコピー機能

### インストール

```bash
npm install -g reviewit
```

### 基本的な使い方

```bash
# 現在のディレクトリの差分をレビュー
reviewit .

# 特定のポートで起動
reviewit . --port 3000
```

ブラウザが開き、レビューインターフェースが表示されます。

### 自動起動の設定

#### スクリプトの作成

**ファイル**: `~/.claude/scripts/launch-reviewit.sh`
```bash
#!/bin/bash

REPO_PATH="${1:-$(pwd)}"

cd "$REPO_PATH" || exit 1

# Git差分がある場合のみ起動
if [[ -n $(git diff --name-only) || \
      -n $(git diff --cached --name-only) || \
      -n $(git ls-files --others --exclude-standard) ]]; then

  # 利用可能なポートを探す
  max_attempts=1000
  attempt=0

  while [ $attempt -lt $max_attempts ]; do
    port=$((RANDOM % 6000 + 4000))

    # ポートが使用されていないか確認
    if ! lsof -Pi :$port -sTCP:LISTEN -t >/dev/null 2>&1; then
      echo "Starting reviewit on port $port..."
      reviewit . --port $port &
      break
    fi

    ((attempt++))
  done

  if [ $attempt -eq $max_attempts ]; then
    echo "Error: Could not find an available port" >&2
    exit 1
  fi
else
  echo "No changes to review"
fi
```

#### 実行権限の付与

```bash
chmod a+x ~/.claude/scripts/launch-reviewit.sh
```

#### Hookへの設定

**.claude/settings.local.json**:
```json
{
  "hooks": {
    "Stop": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "~/.claude/scripts/launch-reviewit.sh /path/to/project"
          }
        ]
      }
    ]
  }
}
```

または、現在のディレクトリを自動で使用:
```json
{
  "hooks": {
    "Stop": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "~/.claude/scripts/launch-reviewit.sh $(pwd)"
          }
        ]
      }
    ]
  }
}
```

### reviewitの活用フロー

1. **Claude Codeで実装**
```bash
> ユーザープロフィール編集機能を実装してください
```

2. **自動的にreviewitが起動**
   - タスク完了時、Hookが発火
   - ブラウザでレビューインターフェースが開く

3. **コードをレビュー**
   - 変更を1つずつ確認
   - 問題があればコメント

4. **Claude Codeにフィードバック**
```bash
> 以下の点を修正してください:
  - [コメント1]
  - [コメント2]
```

5. **修正後、再度レビュー**
   - 新しいreviewitセッションで確認

## カスタム通知スクリプト

### 包括的な通知スクリプト

**ファイル**: `~/.claude/scripts/task-notification.sh`
```bash
#!/bin/bash

# 通知メッセージ
MESSAGE="${1:-Task completed}"
TITLE="${2:-Claude Code}"

# 通知方法を環境変数で制御
NOTIFICATION_METHOD="${CLAUDE_NOTIFICATION:-all}"

# 音声通知
if [[ "$NOTIFICATION_METHOD" == "all" || "$NOTIFICATION_METHOD" == "voice" ]]; then
  if command -v say &> /dev/null; then
    say "$MESSAGE"
  fi
fi

# デスクトップ通知
if [[ "$NOTIFICATION_METHOD" == "all" || "$NOTIFICATION_METHOD" == "desktop" ]]; then
  # macOS
  if [[ "$OSTYPE" == "darwin"* ]]; then
    osascript -e "display notification \"$MESSAGE\" with title \"$TITLE\""

  # Linux
  elif command -v notify-send &> /dev/null; then
    notify-send "$TITLE" "$MESSAGE"

  # Windows (WSL)
  elif command -v powershell.exe &> /dev/null; then
    powershell.exe -Command "[System.Windows.Forms.MessageBox]::Show('$MESSAGE', '$TITLE')"
  fi
fi

# ログに記録
if [[ "$NOTIFICATION_METHOD" == "all" || "$NOTIFICATION_METHOD" == "log" ]]; then
  echo "[$(date '+%Y-%m-%d %H:%M:%S')] $TITLE: $MESSAGE" >> ~/.claude/notification.log
fi

# Slack通知（オプション）
if [[ -n "$SLACK_WEBHOOK_URL" ]]; then
  curl -X POST "$SLACK_WEBHOOK_URL" \
    -H 'Content-Type: application/json' \
    -d "{\"text\": \"$TITLE: $MESSAGE\"}" \
    2>/dev/null
fi
```

#### 実行権限の付与

```bash
chmod a+x ~/.claude/scripts/task-notification.sh
```

#### 使用方法

**.claude/settings.local.json**:
```json
{
  "hooks": {
    "Stop": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "~/.claude/scripts/task-notification.sh 'Task completed' 'Claude Code'"
          }
        ]
      }
    ]
  }
}
```

#### 環境変数での制御

```bash
# 音声通知のみ
export CLAUDE_NOTIFICATION=voice

# デスクトップ通知のみ
export CLAUDE_NOTIFICATION=desktop

# ログのみ
export CLAUDE_NOTIFICATION=log

# すべて（デフォルト）
export CLAUDE_NOTIFICATION=all

# Slack通知も有効化
export SLACK_WEBHOOK_URL="https://hooks.slack.com/services/YOUR/WEBHOOK/URL"
```

### タスクの種類による通知の切り替え

**ファイル**: `~/.claude/scripts/smart-notification.sh`
```bash
#!/bin/bash

# Git差分をチェック
CHANGES=$(git diff --stat)

# 変更の規模を判定
LINES_CHANGED=$(echo "$CHANGES" | tail -n 1 | awk '{print $4+$6}')

if [ -z "$LINES_CHANGED" ]; then
  # 変更なし
  exit 0
elif [ "$LINES_CHANGED" -lt 10 ]; then
  # 小規模な変更: デスクトップ通知のみ
  osascript -e 'display notification "Small changes completed" with title "Claude Code"'
elif [ "$LINES_CHANGED" -lt 100 ]; then
  # 中規模な変更: 音声+デスクトップ通知
  say "Medium-sized changes completed"
  osascript -e 'display notification "Medium changes completed. Review recommended." with title "Claude Code"'
else
  # 大規模な変更: 音声+デスクトップ通知+reviewit
  say "Large changes completed. Please review carefully."
  osascript -e 'display notification "Large changes completed. Opening reviewit..." with title "Claude Code"'
  ~/.claude/scripts/launch-reviewit.sh $(pwd)
fi
```

**設定**:
```json
{
  "hooks": {
    "Stop": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "~/.claude/scripts/smart-notification.sh"
          }
        ]
      }
    ]
  }
}
```

## タスク種別による自動化

### ビルド完了時の通知

**ファイル**: `~/.claude/scripts/build-notification.sh`
```bash
#!/bin/bash

# 最新のビルドログを確認
if [ -f "build.log" ]; then
  if grep -q "Build succeeded" build.log; then
    say "Build succeeded!"
    osascript -e 'display notification "Build completed successfully" with title "Success" sound name "Glass"'
  elif grep -q "Build failed" build.log; then
    say "Build failed!"
    osascript -e 'display notification "Build failed. Check the logs." with title "Error" sound name "Basso"'
  fi
fi
```

### テスト完了時の通知

**ファイル**: `~/.claude/scripts/test-notification.sh`
```bash
#!/bin/bash

# テスト結果を確認
if npm test --silent 2>&1 | grep -q "PASS"; then
  TEST_SUMMARY=$(npm test --silent 2>&1 | tail -n 5)
  say "All tests passed!"
  osascript -e "display notification \"$TEST_SUMMARY\" with title \"Tests Passed\" sound name \"Glass\""
else
  say "Some tests failed!"
  osascript -e 'display notification "Check the test output" with title "Tests Failed" sound name "Basso"'
fi
```

## 時間帯による通知の制御

**ファイル**: `~/.claude/scripts/time-aware-notification.sh`
```bash
#!/bin/bash

HOUR=$(date +%H)
MESSAGE="$1"

# 夜間（22時〜7時）: デスクトップ通知のみ
if [ "$HOUR" -ge 22 ] || [ "$HOUR" -lt 7 ]; then
  osascript -e "display notification \"$MESSAGE\" with title \"Claude Code\""

# 日中: 音声+デスクトップ通知
else
  say "$MESSAGE"
  osascript -e "display notification \"$MESSAGE\" with title \"Claude Code\""
fi
```

**設定**:
```json
{
  "hooks": {
    "Stop": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "~/.claude/scripts/time-aware-notification.sh 'Task completed'"
          }
        ]
      }
    ]
  }
}
```

## トラブルシューティング

### 問題1: 通知が動作しない

**確認1: コマンドのパス**
```bash
# コマンドが利用可能か確認
which say
which osascript
which notify-send

# スクリプトの実行権限
ls -la ~/.claude/scripts/
```

**確認2: スクリプトの動作テスト**
```bash
# 直接実行してみる
~/.claude/scripts/task-notification.sh "Test message"
```

**確認3: JSON構文エラー**
```bash
# settings.jsonの構文チェック
cat .claude/settings.local.json | jq .
```

### 問題2: reviewitが起動しない

**確認1: reviewitのインストール**
```bash
which reviewit
npm list -g reviewit
```

**確認2: Git差分の存在**
```bash
# 差分があるか確認
git status
git diff --stat
```

**確認3: ポートの競合**
```bash
# 使用中のポートを確認
lsof -i :4000-10000
```

### 問題3: 通知が多すぎる

**解決策**: 条件付き通知

```bash
#!/bin/bash

# 前回の通知から5分以上経過している場合のみ通知
LAST_NOTIF_FILE="$HOME/.claude/last_notification"
CURRENT_TIME=$(date +%s)

if [ -f "$LAST_NOTIF_FILE" ]; then
  LAST_TIME=$(cat "$LAST_NOTIF_FILE")
  TIME_DIFF=$((CURRENT_TIME - LAST_TIME))

  # 5分 = 300秒
  if [ $TIME_DIFF -lt 300 ]; then
    exit 0
  fi
fi

# 通知を実行
say "Task completed"
echo "$CURRENT_TIME" > "$LAST_NOTIF_FILE"
```

## プロジェクト固有の自動化

### プロジェクトタイプ別の通知

**フロントエンドプロジェクト**:
```json
{
  "hooks": {
    "Stop": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "npm run lint && npm run typecheck && say 'Frontend task completed'"
          }
        ]
      }
    ]
  }
}
```

**バックエンドプロジェクト**:
```json
{
  "hooks": {
    "Stop": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "npm test && say 'Backend task completed'"
          }
        ]
      }
    ]
  }
}
```

## ベストプラクティス

### 1. 環境依存を最小化

```bash
# ✅ クロスプラットフォーム対応
if [[ "$OSTYPE" == "darwin"* ]]; then
  # macOS
  say "Task completed"
elif command -v notify-send &> /dev/null; then
  # Linux
  notify-send "Task completed"
fi
```

### 2. 通知のON/OFF切り替え

```bash
# 環境変数で制御
if [[ "$CLAUDE_NOTIFY" != "false" ]]; then
  say "Task completed"
fi
```

```bash
# 通知を無効化
export CLAUDE_NOTIFY=false
```

### 3. エラーハンドリング

```bash
# エラーを無視して続行
say "Task completed" 2>/dev/null || true
```

### 4. ログの定期的なクリーンアップ

```bash
# 古いログを削除（30日以上前）
find ~/.claude -name "*.log" -mtime +30 -delete
```

## まとめ

### 通知方法の選択

| 方法 | メリット | デメリット | 推奨シーン |
|-----|---------|-----------|-----------|
| Terminal Bell | 簡単 | 気づきにくい | 短時間タスク |
| 音声通知 | 確実 | 環境依存 | 長時間タスク |
| デスクトップ通知 | 視覚的 | OS依存 | バックグラウンド作業 |
| reviewit | 詳細確認 | セットアップ必要 | コードレビュー |

### 推奨設定

```json
{
  "hooks": {
    "Stop": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "~/.claude/scripts/smart-notification.sh"
          }
        ]
      }
    ]
  }
}
```

### 自動化のメリット

1. **効率化**: 時間の有効活用
2. **品質向上**: すぐにレビューできる
3. **ストレス削減**: 待ち時間の不安がない
4. **生産性向上**: マルチタスクが可能

これで第2部「実践編」の第4章〜第6章の全ファイルが完成しました。実践的で、すぐに使える内容となっています。
