# 06. 効果的なプロンプトの書き方

## この章で学ぶこと

Claude Codeから最高の結果を引き出すためのプロンプトテクニックを学びます。明確な指示の出し方、think/ultrathinkの活用、型定義を使った精度向上、構造化された指示など、実践的なコミュニケーション技術を習得します。

## プロンプトの基本原則

### 原則1: 明確性（Clarity）

**悪い例**:
```bash
> このコードを良くして
```

**良い例**:
```bash
> src/components/Button.tsx のパフォーマンスを改善してください。

  問題点:
  - 毎回再レンダリングされている
  - 不要なpropsが渡されている

  改善方法:
  - React.memoでメモ化
  - propsの最適化
```

### 原則2: 具体性（Specificity）

**悪い例**:
```bash
> ユーザー機能を作って
```

**良い例**:
```bash
> ユーザープロフィール編集機能を実装してください。

  要件:
  - ファイル: src/components/UserProfileEdit.tsx
  - 編集項目: 名前、メールアドレス、プロフィール画像
  - バリデーション: React Hook Form + Zod
  - APIエンドポイント: PUT /api/users/:id
  - 技術スタック: Next.js 14, TypeScript
```

### 原則3: 構造化（Structure）

**悪い例**:
```bash
> ログイン機能を作って、メールとパスワードで、JWTを使って、
  エラーハンドリングもして、テストも書いて...
```

**良い例**:
```bash
> ログイン機能を実装してください。

  ## 要件
  - メール/パスワード認証
  - JWTトークン発行
  - セッション有効期限: 24時間

  ## 技術スタック
  - Next.js API Routes
  - Prisma
  - bcrypt
  - jsonwebtoken

  ## エラーハンドリング
  - 認証失敗時: 401エラー
  - バリデーションエラー: 400エラー

  ## テスト
  - 成功ケース
  - 失敗ケース（パスワード間違い）
  - 失敗ケース（ユーザー存在しない）
```

## Think機能の活用

### Thinkレベルの使い分け

#### 基本的な実装: think

```bash
> この機能の実装方針を提案してください think
```

**使用シーン**:
- 標準的な実装
- 明確な要件がある場合
- 一般的なパターンの適用

#### 複雑な問題: think hard

```bash
> この設計の問題点を分析してください think hard
```

**使用シーン**:
- 複数の選択肢がある場合
- トレードオフの検討が必要
- アーキテクチャの決定

#### さらに深い分析: think harder

```bash
> セキュリティとパフォーマンスの両面から
  最適な実装方法を提案してください think harder
```

**使用シーン**:
- セキュリティクリティカルな実装
- パフォーマンスの最適化
- 複雑な設計決定

#### 最大限の思考: ultrathink

```bash
> この設計が5年後も通用するか検証してください ultrathink
```

**使用シーン**:
- 長期的な影響がある決定
- 根本的な設計変更
- 新しいアーキテクチャの採用

### Think使用例

#### 例1: 実装方法の選択

```bash
> ユーザー通知システムの実装方法を提案してください think hard

  制約:
  - リアルタイム配信必須
  - 10万ユーザー対応
  - 月間予算5万円以下

  以下の3つの方法を比較してください:
  1. WebSocket (Socket.io)
  2. Server-Sent Events
  3. Pusher

  各方法のメリット、デメリット、コスト、
  実装の難易度を比較してください。
```

#### 例2: セキュリティレビュー

```bash
> 現在の認証実装をセキュリティ観点でレビューしてください ultrathink

  確認ファイル:
  - src/auth/login.ts
  - src/middleware/auth.ts
  - src/lib/jwt.ts

  確認項目:
  - SQLインジェクション対策
  - XSS対策
  - CSRF対策
  - セッション管理
  - パスワードハッシュ化
```

## 型定義を活用した精度向上

### テクニック1: 欲しい型を先に定義

```bash
> まず、以下の型定義を作成してください:

  ```typescript
  // ユーザープロフィール編集のフォームデータ
  export interface UserProfileFormData {
    name: string;           // 1-50文字
    email: string;          // メール形式
    bio?: string;           // 最大500文字、オプショナル
    avatarUrl?: string;     // URL形式、オプショナル
    birthDate: Date;        // 過去の日付のみ
  }

  // APIレスポンス
  export interface UpdateProfileResponse {
    success: boolean;
    user: User;
    errors?: ValidationError[];
  }
  ```

  この型定義に基づいて、プロフィール編集機能を実装してください。
```

### テクニック2: 制約をコメントで明記

```typescript
// 日付ごとにToDoをまとめた結果
export type TodosByDate = Record<
  string,  // "YYYY-MM-DD" 形式の日付
  Array<{
    id: string;
    title: string;      // 1-100文字
    completed: boolean;
    priority: 'low' | 'medium' | 'high';  // この3つのみ
  }>
>;
```

```bash
> この型定義に合うように、
  todoをグループ化する関数を実装してください。

  入力: Todo[]
  出力: TodosByDate

  エッジケース:
  - 日付が未設定のTodoは「unscheduled」キーにグループ化
  - 空の配列の場合は{}を返す
```

### テクニック3: Zodスキーマの活用

```bash
> まず、以下のZodスキーマを作成してください:

  ```typescript
  import { z } from 'zod';

  export const UserRegistrationSchema = z.object({
    email: z.string().email('有効なメールアドレスを入力してください'),
    password: z.string()
      .min(8, 'パスワードは8文字以上')
      .regex(/[A-Z]/, '大文字を1つ以上含めてください')
      .regex(/[0-9]/, '数字を1つ以上含めてください'),
    name: z.string()
      .min(1, '名前は必須です')
      .max(50, '名前は50文字以内'),
    agreeToTerms: z.literal(true, {
      errorMap: () => ({ message: '利用規約への同意が必要です' })
    })
  });

  export type UserRegistrationInput = z.infer<typeof UserRegistrationSchema>;
  ```

  このスキーマを使って、ユーザー登録フォームを実装してください。
```

## 構造化されたプロンプトのテンプレート

### テンプレート1: 機能実装

```bash
> [機能名]を実装してください。

  ## 要件
  - [要件1]
  - [要件2]
  - [要件3]

  ## 技術スタック
  - [技術1]
  - [技術2]

  ## ファイル構成
  - [ファイル1]: [役割]
  - [ファイル2]: [役割]

  ## 制約
  - [制約1]
  - [制約2]

  ## テスト要件
  - [テストケース1]
  - [テストケース2]
```

### テンプレート2: バグ修正

```bash
> [バグの説明]を修正してください。

  ## 再現手順
  1. [手順1]
  2. [手順2]
  3. [手順3]

  ## 期待される動作
  [期待される動作の説明]

  ## 実際の動作
  [実際の動作の説明]

  ## エラーメッセージ
  ```
  [エラーメッセージ]
  ```

  ## 疑わしい箇所
  - [ファイル名]の[関数名]
  - 特に[具体的な箇所]を確認してください
```

### テンプレート3: リファクタリング

```bash
> [対象]をリファクタリングしてください。

  ## 現在の問題点
  - [問題点1]
  - [問題点2]
  - [問題点3]

  ## 改善目標
  - [目標1]
  - [目標2]
  - [目標3]

  ## 制約
  - [制約1]: 既存の動作を変えない
  - [制約2]: テストは全て通ること
  - [制約3]: [その他の制約]

  ## 望ましいアプローチ
  - [アプローチ1]
  - [アプローチ2]
```

### テンプレート4: コードレビュー

```bash
> [対象]をレビューしてください。

  ## レビュー観点
  - [ ] セキュリティ
  - [ ] パフォーマンス
  - [ ] 可読性
  - [ ] 保守性
  - [ ] テストカバレッジ

  ## 特に確認してほしい点
  - [ポイント1]
  - [ポイント2]

  ## プロジェクトのコーディング規約
  - [規約1]
  - [規約2]
```

## コンテキストを効果的に渡すテクニック

### テクニック1: @記法でファイル指定

```bash
> 以下のファイルを確認してください:
  @src/components/UserProfile.tsx
  @src/hooks/useUser.ts
  @src/types/user.ts

  これらの実装パターンに従って、
  UserProfileEditコンポーネントを作成してください。
```

### テクニック2: VSCode拡張機能の活用

```bash
# VS Codeで関連ファイルを開く
# 自動的にコンテキストに追加される

> 開いているファイルを確認して、
  統一されたコーディングスタイルで実装してください。
```

### テクニック3: 型定義+コメントで詳細を伝える

```typescript
/**
 * ユーザーのプロフィール情報
 *
 * @property id - UUID形式の一意な識別子
 * @property email - 重複不可、認証に使用
 * @property name - 表示名、1-50文字
 * @property role - 'admin' | 'user' | 'guest' のいずれか
 * @property createdAt - 登録日時、タイムゾーンはUTC
 * @property updatedAt - 最終更新日時、自動更新
 */
export interface User {
  id: string;
  email: string;
  name: string;
  role: UserRole;
  createdAt: Date;
  updatedAt: Date;
}
```

```bash
> この型定義に基づいて、ユーザー管理APIを実装してください。
```

## 実践例: プロンプトの進化

### レベル1: 初心者（曖昧）

```bash
> ログイン機能を作って
```

**問題点**:
- 技術スタックが不明
- 要件が不明確
- 実装範囲が不明

### レベル2: 中級者（具体的）

```bash
> ログイン機能を実装してください。
  メールとパスワードで認証。
  Next.jsとPrismaを使用。
  JWTでセッション管理。
```

**改善点**:
- 技術スタックが明確
- 基本要件が定義

**問題点**:
- エラーハンドリングが不明
- テストが不明
- ファイル構成が不明

### レベル3: 上級者（構造化+詳細）

```bash
> ログイン機能を実装してください。

  ## 要件
  ### 認証方式
  - メールアドレス + パスワード
  - パスワードは bcrypt でハッシュ化
  - JWTトークンでセッション管理
  - トークン有効期限: 24時間

  ### エラーハンドリング
  - 認証失敗: 401 + { error: "Invalid credentials" }
  - メール未確認: 403 + { error: "Email not verified" }
  - アカウントロック: 403 + { error: "Account locked" }

  ## 技術スタック
  - Next.js 14 API Routes
  - Prisma ORM
  - bcrypt (パスワードハッシュ)
  - jsonwebtoken (JWT生成)
  - Zod (バリデーション)

  ## ファイル構成
  - src/app/api/auth/login/route.ts: APIエンドポイント
  - src/lib/auth.ts: 認証ロジック
  - src/lib/jwt.ts: JWT関連ユーティリティ
  - src/types/auth.ts: 型定義

  ## 型定義
  ```typescript
  export interface LoginRequest {
    email: string;
    password: string;
  }

  export interface LoginResponse {
    success: true;
    token: string;
    user: {
      id: string;
      email: string;
      name: string;
    };
  }

  export interface LoginErrorResponse {
    success: false;
    error: string;
  }
  ```

  ## セキュリティ要件
  - レート制限: 5回/分
  - ログイン試行回数制限: 5回でアカウントロック
  - パスワードは平文でログに出力しない
  - CSRF対策を実装

  ## テスト要件
  - 成功ケース
  - パスワード間違い
  - ユーザー存在しない
  - メール未確認
  - アカウントロック
  - レート制限

  まず、型定義とバリデーションスキーマを作成してから、
  APIエンドポイントを実装してください。
```

## よくある失敗パターンと改善策

### 失敗パターン1: 曖昧な指示

❌ **悪い例**:
```bash
> このコードをもっと良くして
```

✅ **改善例**:
```bash
> src/utils/formatDate.ts のパフォーマンスを改善してください。

  現状:
  - 1000回の呼び出しで200ms
  - 毎回Dateオブジェクトを生成

  目標:
  - 1000回の呼び出しで50ms以下

  アプローチ:
  - メモ化の導入
  - 不要なDateオブジェクト生成の削減
```

### 失敗パターン2: 一度に詰め込みすぎ

❌ **悪い例**:
```bash
> ユーザー認証機能を作って、登録もログインもパスワードリセットも
  ソーシャルログインも2要素認証も全部実装して...
```

✅ **改善例**:
```bash
# ステップ1
> まず基本的なログイン機能を実装してください。
  [詳細な要件]

# ステップ2
> 次にユーザー登録機能を実装してください。
  [詳細な要件]

# ステップ3
> パスワードリセット機能を実装してください。
  [詳細な要件]
```

### 失敗パターン3: コンテキストの欠如

❌ **悪い例**:
```bash
> この関数を修正して
```

✅ **改善例**:
```bash
> src/utils/calculation.ts の calculateTotal 関数を修正してください。

  問題:
  - 空配列の場合にNaNを返す

  期待される動作:
  - 空配列の場合は0を返す

  テストケース:
  - calculateTotal([]) => 0
  - calculateTotal([10, 20]) => 30
```

### 失敗パターン4: 暗黙の期待

❌ **悪い例**:
```bash
> APIエンドポイントを作って
```

✅ **改善例**:
```bash
> APIエンドポイントを作成してください。

  エンドポイント: POST /api/users

  リクエスト:
  ```typescript
  {
    email: string;
    password: string;
    name: string;
  }
  ```

  レスポンス (成功):
  ```typescript
  {
    success: true;
    user: {
      id: string;
      email: string;
      name: string;
    }
  }
  ```

  レスポンス (失敗):
  ```typescript
  {
    success: false;
    error: string;
    details?: ValidationError[];
  }
  ```

  バリデーション:
  - email: メール形式、必須
  - password: 8文字以上、必須
  - name: 1-50文字、必須

  エラーコード:
  - 400: バリデーションエラー
  - 409: メールアドレス重複
  - 500: サーバーエラー
```

## まとめ

### 効果的なプロンプトの5原則

1. **明確性**: 何をしたいか明確に
2. **具体性**: 詳細を提供
3. **構造化**: 整理された形式で
4. **型定義**: 型で制約を伝える
5. **段階的**: 小さく分けて

### Think機能の活用

- **think**: 標準的な実装
- **think hard**: 複雑な問題
- **think harder**: より深い分析
- **ultrathink**: 最大限の思考

### プロンプトテンプレート

- 機能実装
- バグ修正
- リファクタリング
- コードレビュー

### 次のステップ

これで第5章「効果的なワークフロー」は完了です。次の第6章「コマンドとカスタマイズ」では、スラッシュコマンド、カスタムコマンドの作成、Hooksの活用など、Claude Codeのカスタマイズ機能を学びます。
