# 02. コンテキスト管理のコツ

## この章で学ぶこと

Claude Codeのコンテキストウィンドウを効率的に管理する方法を学びます。/clearと/compactの使い分け、長時間セッションでの精度維持、チェックリスト活用など、実践的なテクニックを習得します。

## コンテキストウィンドウとは？

### 基本概念

コンテキストウィンドウは、Claude Codeが「覚えている」情報の総量です。本棚に例えることができます。

```
コンテキストウィンドウ = 限られた本棚スペース

┌─────────────────────────┐
│ CLAUDE.md               │ ← 常に置かれている
│ settings.json           │ ← 常に置かれている
├─────────────────────────┤
│ あなたの指示            │ ← 会話で増える
│ Claude の返答           │ ← 会話で増える
│ 読み込んだファイル      │ ← 会話で増える
│ 実行結果                │ ← 会話で増える
└─────────────────────────┘

コンテキストウィンドウのサイズ (2025年11月時点):
- デフォルト: 約20万トークン（約15万文字相当）
- Claude Sonnet 4/4.5: 約100万トークン(プレビュー)
```

### コンテキストが肥大化すると起こる問題

1. **応答精度の低下**
   - 関係ない情報が混ざる
   - 重要な情報を見落とす

2. **トークン消費の増加**
   - API使用量が増える
   - コストが上がる

3. **応答速度の低下**
   - 処理に時間がかかる

## /clearコマンド: コンテキストの完全リセット

### 基本的な使い方

```bash
> /clear
```

このコマンドは、会話履歴を完全にリセットします。

### /clearを使うべきタイミング

#### 1. タスクが完全に変わる時

```bash
# ユーザー認証機能を実装完了
> 認証機能のテストも完了しました

> /clear

# 全く別の機能に移る
> 検索機能を実装してください
```

#### 2. エラーが続いて混乱した時

```bash
# 何度も修正を試みたが解決しない
> この問題の解決方法がわかりません

> /clear

# 新しい視点で再挑戦
> あらためて、この問題を解決してください
  [問題の説明を新しく書く]
```

#### 3. 大きな方向転換をする時

```bash
# REST APIで実装していたが、GraphQLに変更
> /clear

> GraphQLでAPIを再設計してください
```

#### 4. 作業が一段落した時

```bash
> プルリクエストを作成しました

> /clear

# 次のイシューに取り組む
> Issue #123の対応を始めます
```

### /clearの効果

**リセットされるもの**:
- 会話履歴
- 読み込んだファイルの内容
- 実行結果
- 中間的な決定事項

**保持されるもの**:
- CLAUDE.md の内容
- settings.json の設定
- カスタムコマンド

### /clear後のベストプラクティス

```bash
# 1. /clearを実行
> /clear

# 2. 新しいタスクの概要を伝える
> これから検索機能を実装します。
  技術スタック:
  - Next.js App Router
  - Algolia
  - TypeScript

# 3. 関連ファイルを読み込ませる
> 以下のファイルを確認してください:
  - src/components/SearchBar.tsx
  - src/hooks/useSearch.ts
```

## /compactコマンド: コンテキストの圧縮

### 基本的な使い方

```bash
> /compact
```

このコマンドは、会話を要約してトークン使用量を削減します。

### /compactを使うべきタイミング

#### 1. 長い会話が続いた時

```bash
# 2時間作業を続けた後
> /compact
```

#### 2. タスクは継続するが区切りが良い時

```bash
# 認証機能の実装が完了
> 認証機能の実装が完了しました

> /compact 認証機能の実装内容は保持してください

# 関連する次のタスク
> 次は認証が必要なダッシュボード画面を作ります
```

#### 3. 無駄な試行錯誤が多かった時

```bash
# 何度も修正を繰り返した
> やっと動くようになりました

> /compact 最終的な実装方法だけ保持してください
```

### /compactの効果

**圧縮されるもの**:
- 会話の詳細なやり取り
- 試行錯誤の過程
- エラーメッセージの詳細

**要約として保持されるもの**:
- 重要な決定事項
- 実装した機能の概要
- 技術的な選択の理由

### /compact with 引数

特定の内容を保持したい場合、引数を指定できます。

```bash
# 認証機能の内容だけ保持
> /compact 認証機能の実装内容だけ保持

# データベース設計を保持
> /compact データベーススキーマの決定事項を保持

# 特定の技術選択を保持
> /compact Next.js App Routerの使い方を保持
```

## /clearと/compactの使い分け

### 判断フローチャート

```
タスクが変わる？
├─ YES: 完全に別のタスク？
│  ├─ YES → /clear を使用
│  └─ NO: 関連するタスク？
│     └─ YES → /compact を使用
│
└─ NO: 会話が長くなった？
   ├─ YES → /compact を使用
   └─ NO: そのまま続行
```

### 具体例で比較

#### ケース1: 認証 → 検索（関係なし）

```bash
# 認証機能完了
> /clear  ← 全く別の機能なので完全リセット

# 検索機能開始
```

#### ケース2: 認証 → ダッシュボード（関係あり）

```bash
# 認証機能完了
> /compact 認証機能の実装を保持  ← 関連するので要約

# ダッシュボード開始（認証が必要）
```

#### ケース3: 長時間の実装作業

```bash
# 2時間作業を続けた
> /compact  ← 重要な内容は保持しつつ圧縮

# 作業継続
```

### 使い分けの表

| 状況 | 使用コマンド | 理由 |
|-----|------------|------|
| 全く別のタスクに移行 | /clear | コンテキストの完全クリアが必要 |
| 関連タスクに移行 | /compact | 前の内容を引き継ぎたい |
| 長時間セッション | /compact | トークン節約 |
| エラーで混乱 | /clear | フレッシュな状態で再挑戦 |
| 方針の大転換 | /clear | 過去の方針を引きずりたくない |
| 一連の実装完了 | /compact | 成果だけ残して次へ |

## 長時間セッションの管理テクニック

### テクニック1: チェックリストの活用

大量のタスクがある場合は、Markdownファイルでチェックリストを作ります。

#### ステップ1: チェックリスト作成

```bash
> 以下のlintエラーをすべてchecklist.mdに書き出してください:
  - [ ] src/components/Button.tsx: Unused variable 'onClick'
  - [ ] src/hooks/useUser.ts: Missing return type
  - [ ] src/pages/index.tsx: Any type is not allowed
  [さらに50個のエラー...]
```

#### ステップ2: 段階的に修正

```bash
> checklist.mdの最初の10個のエラーを修正してください。
  完了したらチェックを入れてください。
```

#### ステップ3: 定期的に/compact

```bash
# 10個修正後
> /compact チェックリストの進捗を保持

# 次の10個
> checklist.mdの次の10個を修正してください
```

#### ステップ4: 進捗報告

```bash
> 10個修正するごとに進捗を報告してください
```

### テクニック2: 外部ファイルへの記録

重要な決定事項や実装方針は、別ファイルに残します。

```bash
# 実装方針を記録
> 今回の認証実装の方針をimplementation_notes.mdにまとめてください。
  以下を含めてください:
  - 採用した技術（NextAuth.js）とその理由
  - セッション管理の方法
  - 今後の改善案

# /clearして次のタスク
> /clear

# 必要に応じて読み込む
> implementation_notes.mdを確認して、認証の実装方針を教えてください
```

### テクニック3: マイルストーンでの区切り

機能単位で/compactを実行します。

```bash
# フェーズ1: 基本実装
> ユーザー登録機能を実装

> /compact ユーザー登録の実装を保持

# フェーズ2: バリデーション追加
> バリデーションを追加

> /compact 登録とバリデーションを保持

# フェーズ3: エラーハンドリング
> エラーハンドリングを追加

> /compact 完成した登録機能を保持
```

### テクニック4: 定期的なセーブポイント

git addで良い状態を保存しながら進めます。

```bash
# 良い状態になったらすぐsave
> いい感じです。git addしてください

# 次の機能に進む
> 次はログイン機能を実装します

# 問題が起きたらリセット
> 上手くいきません。git resetで戻してください
```

## コンテキスト節約のテクニック

### テクニック1: 短く具体的な指示

❌ **冗長な指示**:
```bash
> ユーザーがログインできるような機能を作ってほしいんだけど、
  メールアドレスとパスワードで認証できるようにして、
  あと、パスワードを忘れた時の機能もあったほうがいいと思うし、
  ソーシャルログインもできたら便利かもしれないけど、
  とりあえず基本的な機能から始めて...
```

✅ **簡潔な指示**:
```bash
> ログイン機能を実装してください。

  要件:
  - メール/パスワード認証
  - JWT使用
  - Next.js + TypeScript

  今回は基本機能のみ。ソーシャルログインは後回し。
```

### テクニック2: 必要な部分だけ読み込む

❌ **ファイル全体を読み込む**:
```bash
> package-lock.json を確認してください
```

✅ **必要な部分だけ指定**:
```bash
> package.json の dependencies だけ確認してください
```

### テクニック3: Plan Modeで事前計画

大きな変更の前に、Plan Modeで計画を立てます。

```bash
# Plan Modeに切り替え（Shift+Tab 2回）

> データベーススキーマを全面的に見直したいです。
  実装計画を立ててください。

# 計画を確認してから実装モードに戻る
```

これにより、無駄な試行錯誤を防げます。

### テクニック4: 大きなファイルは分割参照

```bash
# ❌ 一度に全部読み込む
> src/components/LargeComponent.tsx を確認してください

# ✅ セクションごとに読み込む
> src/components/LargeComponent.tsx の型定義部分だけ確認してください
> 次にロジック部分を確認してください
```

## 実践シナリオ

### シナリオ1: 長時間の機能開発

```bash
# 9:00 - セッション開始
> 新しいユーザーダッシュボードを実装します

# 10:30 - 基本実装完了
> /compact ダッシュボードの基本実装を保持

# 12:00 - データフェッチング追加
> データフェッチングを実装します

# 13:30 - ランチ休憩前
> /compact ダッシュボード実装の全体を保持

# 14:30 - 午後の作業開始
> 午前中の実装を確認してください
> 次はレスポンシブ対応をします

# 16:00 - UI調整
> /compact 実装内容を保持

# 17:00 - テスト追加
> テストを追加します

# 18:00 - 完了
> /compact
> 今日の実装内容をdaily_notes.mdにまとめてください
```

### シナリオ2: 大量のバグ修正

```bash
# チェックリスト作成
> GitHub Issues の未解決バグをbug_checklist.mdに書き出してください

# 5個ずつ修正
> 最初の5個のバグを修正してください

> /compact チェックリストを保持

> 次の5個を修正してください

# 10個修正ごとに/compact
> /compact 修正済みバグのリストを保持

# 別のタスクに移る前
> /clear
```

### シナリオ3: コードレビュー対応

```bash
# レビューコメント確認
> Pull Request #123 のレビューコメントを確認してください

# 1つずつ対応
> 最初の指摘を修正してください

> git add して、修正をコミットしてください

> /compact 対応済みコメントを保持

# 次の指摘へ
> 次の指摘を修正してください
```

## トークン使用量の確認

### ccusageツール

```bash
# 日次の使用量を確認
npx ccusage@latest

# 現在のセッションを確認
npx ccusage@latest blocks
```

### 使用量が多い場合の対策

1. **/compactを実行**
```bash
> /compact
```

2. **不要な情報を削除**
```bash
> 現在のコンテキストから、試行錯誤の過程は削除して、
  最終的な実装方法だけ保持してください
```

3. **新しいセッションを開始**
```bash
> 重要な決定事項をnotes.mdに保存してください
> /clear
> notes.mdを確認してください
```

## まとめ

### コンテキスト管理の5原則

1. **定期的にリセット**
   - タスクが変わったら/clear
   - 長時間作業なら/compact

2. **簡潔な指示**
   - 要点だけを伝える
   - 構造化された指示

3. **必要最小限の読み込み**
   - ファイル全体ではなく必要な部分
   - 段階的に読み込む

4. **外部ファイルに記録**
   - 重要な決定事項は別ファイルに
   - いつでも参照できる状態に

5. **チェックリストで管理**
   - 大量のタスクは可視化
   - 進捗を明確に

### コマンド使い分けまとめ

| コマンド | タイミング | 保持される内容 |
|---------|----------|--------------|
| /clear | タスク完全切り替え | CLAUDE.md, settings.json |
| /compact | 関連タスクへ移行 | 要約された会話内容 |
| /compact [指定] | 特定内容を保持 | 指定した内容の要約 |

### 次のステップ

次の章では、Plan Modeの詳細な活用方法を学びます。事前計画によってコンテキストを節約しながら、より高品質な実装を実現する方法を習得します。
