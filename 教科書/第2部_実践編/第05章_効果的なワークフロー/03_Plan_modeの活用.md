# 03. Plan Modeの活用

## この章で学ぶこと

Plan Modeは、実装前に計画を立てるための特別なモードです。この章では、Plan Modeの使い方、いつ使うべきか、そして効果的な活用方法を学びます。

## Plan Modeとは？

### 基本概念

Plan Modeは、コードの実装や実行を行わずに、計画や設計だけを行うモードです。

**通常モード vs Plan Mode**:

```
通常モード（デフォルト）
├─ ファイルの読み書き
├─ コマンドの実行
├─ コードの生成
└─ テストの実行

Plan Mode
├─ 計画の立案
├─ 設計の提案
├─ アーキテクチャの検討
└─ 実装方針の決定
```

### Plan Modeのメリット

1. **コンテキストの節約**
   - 実装前に方向性を確認
   - 無駄な試行錯誤を防ぐ

2. **より良い設計**
   - じっくり考える時間
   - 複数の選択肢を比較

3. **チーム共有**
   - 実装前に計画を共有
   - レビューやディスカッション

4. **リスクの早期発見**
   - 実装前に問題を特定
   - 代替案を準備

## Plan Modeの起動方法

### 方法1: キーボードショートカット

```
Shift + Tab を2回押す
```

画面に「Plan」と表示されます。

### 方法2: /planコマンド

```bash
> /plan
```

### 通常モードに戻る

```
Shift + Tab を2回押す（再度トグル）
```

または

```bash
> /normal
```

## いつPlan Modeを使うべきか

### シナリオ1: 大きな機能の実装前

```bash
# Plan Modeに切り替え
> 新しいユーザーダッシュボードを実装したいです。
  以下の要件で実装計画を立ててください:

  要件:
  - ユーザー情報の表示
  - アクティビティフィード
  - 通知機能
  - カスタマイズ可能なウィジェット

  技術スタック:
  - Next.js 14 (App Router)
  - TypeScript
  - Tailwind CSS
  - tRPC
```

**期待される出力**:
- コンポーネント構成
- データフロー
- API設計
- 実装順序
- 潜在的な問題点

### シナリオ2: アーキテクチャの再設計

```bash
# Plan Mode
> 現在のモノリシックな構造をマイクロフロントエンドに
  再設計したいです。実装計画を提案してください think

  制約:
  - 段階的に移行（ビッグバンリライトは避ける）
  - 既存機能は動作し続ける
  - チーム全員が理解できる構造
```

### シナリオ3: パフォーマンス改善

```bash
# Plan Mode
> アプリケーションのパフォーマンスを改善したいです。
  以下を分析して改善計画を立ててください:

  現状:
  - 初回ロード: 5秒
  - Time to Interactive: 8秒
  - バンドルサイズ: 3MB

  目標:
  - 初回ロード: 2秒以下
  - Time to Interactive: 3秒以下
  - バンドルサイズ: 1MB以下
```

### シナリオ4: セキュリティ強化

```bash
# Plan Mode
> アプリケーションのセキュリティを強化したいです。
  現在の実装を確認して、改善計画を立ててください ultrathink

  重点項目:
  - 認証・認可
  - XSS対策
  - CSRF対策
  - SQLインジェクション対策
```

### シナリオ5: データベーススキーマ設計

```bash
# Plan Mode
> 以下の機能に必要なデータベーススキーマを設計してください:

  機能:
  - ユーザー管理
  - 投稿とコメント
  - いいね機能
  - フォロー機能
  - 通知システム

  データベース: PostgreSQL
  ORM: Prisma
```

## Think機能との組み合わせ

Plan Modeでは、Think機能を積極的に活用しましょう。

### Thinkレベルの使い分け

```bash
# 基本的な計画
> 実装計画を立ててください think

# より深い分析
> 複数の実装方法を比較して、
  それぞれのメリット・デメリットを教えてください think hard

# さらに深い検討
> セキュリティ、パフォーマンス、保守性のすべての観点から
  最適な実装方法を提案してください think harder

# 最大限の思考
> この設計の長期的な影響を考慮して、
  5年後も通用する実装方法を提案してください ultrathink
```

## 効果的なPlan Modeの使い方

### ステップ1: 現状の分析

```bash
# Plan Mode
> 現在の認証システムの実装を確認してください。
  以下のファイルを分析してください:
  - src/auth/login.ts
  - src/auth/session.ts
  - src/middleware/auth.ts

  分析してほしい観点:
  - セキュリティ
  - スケーラビリティ
  - 保守性
```

### ステップ2: 要件の整理

```bash
> 分析結果を踏まえて、以下の新要件を満たす実装計画を立ててください:

  新要件:
  - ソーシャルログイン（Google, GitHub）
  - 2要素認証
  - セッションの永続化
  - 複数デバイス対応
```

### ステップ3: 複数案の比較

```bash
> 実装方法を3つ提案してください。
  それぞれのメリット・デメリット、実装コスト、
  保守コストを比較してください think hard
```

### ステップ4: 実装順序の決定

```bash
> 推奨する実装方法について、
  段階的な実装計画を立ててください。
  各段階で必要な作業とテスト項目を教えてください。
```

### ステップ5: リスクの特定

```bash
> この実装計画で起こりうる問題点や
  リスクをリストアップしてください。
  それぞれの対策も提案してください。
```

### ステップ6: 実装開始

```bash
# 通常モードに戻る
Shift + Tab を2回

> 計画に基づいて実装を開始してください。
  まずフェーズ1から。
```

## 実践例: 全プロセス

### 例: E2Eテストの導入

**ステップ1: Plan Modeで計画立案**

```bash
# Plan Modeに切り替え
Shift + Tab × 2

> E2Eテストを導入したいです。
  実装計画を立ててください think

  現状:
  - ユニットテストはJestで実装済み
  - E2Eテストは未導入
  - CI/CDはGitHub Actionsを使用

  要件:
  - 主要なユーザーフローをカバー
  - CI/CDに統合
  - 高速に実行できる
  - 保守しやすい
```

**期待される計画**:

```
# E2Eテスト導入計画

## 1. ツール選定
推奨: Playwright
理由:
- 高速で安定
- クロスブラウザ対応
- TypeScript完全サポート
- デバッグツールが充実

代替案: Cypress
メリット: 豊富なエコシステム
デメリット: Playwrightより遅い

## 2. テスト範囲
優先度の高いフロー:
1. ユーザー登録とログイン
2. 商品の検索と購入
3. プロフィール編集
4. 問い合わせフォーム送信

## 3. 実装手順
フェーズ1: 環境構築（1日）
- Playwrightのインストール
- 基本設定
- CIへの組み込み

フェーズ2: ログインフローのテスト（2日）
- ログインページのテスト
- セッション管理のテスト
- エラーケースのテスト

フェーズ3: 主要フローのテスト（3日）
- 検索機能のテスト
- 購入フローのテスト
- プロフィール編集のテスト

フェーズ4: CI/CDの最適化（1日）
- 並列実行の設定
- テストのグループ化
- 失敗時のスクリーンショット

## 4. 潜在的な問題と対策
問題1: テストの実行時間
対策: 並列実行、必要最小限のテストケース

問題2: フレーキーなテスト
対策: 適切な待機処理、リトライ設定

問題3: テストデータの管理
対策: テスト用DBの準備、データのリセット
```

**ステップ2: 計画の確認とディスカッション**

```bash
> この計画で問題ありそうな点はありますか？
> 他のチームメンバーとも相談したいので、
  この計画をplan_e2e_testing.mdに保存してください
```

**ステップ3: 実装開始**

```bash
# 通常モードに戻る
Shift + Tab × 2

> 計画のフェーズ1から実装を開始してください。
  Playwrightをインストールして基本設定を行なってください。
```

## Plan Modeでのコミュニケーションパターン

### パターン1: オープンな質問

```bash
> ユーザー通知システムを実装したいです。
  実装方法を提案してください。
```

### パターン2: 制約を明示

```bash
> ユーザー通知システムを実装したいです。

  制約:
  - リアルタイム配信必須
  - 10万ユーザーをサポート
  - コストは月5万円以下
  - 既存のNext.jsアプリに統合

  実装方法を提案してください think
```

### パターン3: 比較を依頼

```bash
> ユーザー通知システムの実装方法として、
  以下の3つを比較してください:

  1. WebSocket (Socket.io)
  2. Server-Sent Events
  3. Pusher

  それぞれのメリット、デメリット、
  コスト、実装の難易度を比較してください think hard
```

### パターン4: ステップバイステップ

```bash
> WebSocketを使った通知システムの
  実装手順を教えてください。

  以下の形式でお願いします:
  1. 環境構築
  2. サーバー側の実装
  3. クライアント側の実装
  4. 認証の統合
  5. テスト
  6. デプロイ
```

## Plan Modeの実践テクニック

### テクニック1: 設計図の保存

計画は必ず外部ファイルに保存します。

```bash
# Plan Mode
> この実装計画をdocs/plans/notification_system.mdに保存してください
```

後で参照できるようにします。

```bash
# 通常モード（実装中）
> docs/plans/notification_system.mdを確認して、
  計画通りに実装できているか教えてください
```

### テクニック2: 段階的な詳細化

最初は高レベルな計画から始めます。

```bash
# Plan Mode - 高レベル
> ユーザー通知システムの全体アーキテクチャを提案してください

# 詳細化
> WebSocketサーバーの実装の詳細を教えてください

# さらに詳細化
> 認証とWebSocketの統合方法の詳細を教えてください
```

### テクニック3: 代替案の準備

```bash
# Plan Mode
> 推奨案に加えて、以下の場合の代替案も準備してください:
  - 予算が半分の場合
  - ユーザー数が10倍になった場合
  - 開発期間が半分の場合
```

### テクニック4: レビューの依頼

```bash
# Plan Mode
> この実装計画をレビューしてください。
  以下の観点で問題点を指摘してください:
  - セキュリティ
  - スケーラビリティ
  - 保守性
  - コスト効率
```

## よくあるアンチパターン

### ❌ アンチパターン1: Plan Modeで実装を始める

```bash
# Plan Mode（間違い）
> UserProfile.tsxを作成してください
```

**問題**: Plan Modeは実装しません

**正解**: 通常モードに戻ってから実装

### ❌ アンチパターン2: 計画を立てずに実装

```bash
# 通常モード（間違い）
> いきなり通知システムを実装してください
```

**問題**: 方向性が定まっていない

**正解**: Plan Modeで計画を立ててから実装

### ❌ アンチパターン3: 計画を保存しない

```bash
# Plan Mode
> 実装計画を立ててください

# 計画を聞いただけで通常モードに戻る
```

**問題**: 計画が失われる

**正解**: 必ずファイルに保存

## Plan Modeのチェックリスト

実装前に以下を確認:

- [ ] Plan Modeで計画を立てた
- [ ] 複数の実装方法を比較した
- [ ] リスクと対策を検討した
- [ ] 実装順序を決定した
- [ ] 計画をファイルに保存した
- [ ] 必要に応じてチームと共有した
- [ ] 通常モードに戻って実装開始

## まとめ

### Plan Modeの価値

1. **コンテキスト節約**
   - 無駄な試行錯誤を削減
   - 最初から正しい方向へ

2. **より良い設計**
   - じっくり考える時間
   - 複数案の比較

3. **リスク管理**
   - 事前に問題を発見
   - 対策を準備

4. **チーム共有**
   - 実装前の合意形成
   - ドキュメント化

### 効果的な使い方

1. **大きな変更の前に使う**
2. **Think機能と組み合わせる**
3. **計画は必ず保存する**
4. **実装前に必ずレビューする**

### 次のステップ

次の章では、音声入力を活用したClaude Codeの使い方を学びます。タイピング速度の制限を超えて、より自然なコミュニケーションを実現する方法を習得します。
