# 実践例

## はじめに

この章では、MCPサーバーを実際のプロジェクトで活用する具体的な例を学びます。セットアップから実際の使用方法まで、ステップバイステップで解説します。

## 実践例1: Next.js プロジェクトでの基本セットアップ

### プロジェクト概要

- **フレームワーク**: Next.js 15
- **使用するMCP**: Context7, Playwright
- **目的**: 最新ドキュメント参照とE2Eテスト自動化

### ステップ1: プロジェクトのセットアップ

```bash
# Next.jsプロジェクトの作成
npx create-next-app@latest my-app --typescript
cd my-app
```

### ステップ2: `.mcp.json`の作成

```json
{
  "mcpServers": {
    "context7": {
      "transport": "sse",
      "url": "https://mcp.context7.com/sse"
    },
    "playwright": {
      "command": "npx",
      "args": ["@playwright/mcp"]
    }
  }
}
```

### ステップ3: `.gitignore`の更新

```bash
# .gitignoreに追加
echo ".mcp.json" >> .gitignore
```

### ステップ4: テンプレートファイルの作成

```bash
# テンプレートをコピー
cp .mcp.json .mcp.json.example
```

### ステップ5: READMEの更新

```markdown
## MCP設定

### セットアップ

1. MCP設定ファイルを作成
   \`\`\`bash
   cp .mcp.json.example .mcp.json
   \`\`\`

2. Claude Codeで動作確認
   \`\`\`bash
   claude
   > MCPサーバーが利用可能か確認してください
   \`\`\`

### 使用可能なMCPサーバー

- **Context7**: Next.js 15の最新ドキュメントを参照
- **Playwright**: E2Eテストの自動生成
```

### 実際の使用例

```
> Context7を使って、Next.js 15のApp Routerで
> Server Componentsとクライアントコンポーネントを
> 適切に使い分けたページを作成してください
```

Claude Codeの応答:
```
Context7から最新のNext.js 15ドキュメントを取得しました...

【最新のベストプラクティス】
- Server Components: データフェッチ、SEO重視
- Client Components: インタラクティブ性、状態管理

【実装開始】
app/
├── page.tsx (Server Component)
├── components/
│   └── InteractiveSection.tsx (Client Component)
```

## 実践例2: デザインシステム開発でのFigma連携

### プロジェクト概要

- **フレームワーク**: React + TypeScript + Tailwind CSS
- **使用するMCP**: Figma, Context7, Playwright
- **目的**: Figmaのデザインをコンポーネント化

### ステップ1: Figmaアクセストークンの取得

1. Figmaにログイン
2. Settings → Account → Personal Access Tokens
3. 「Generate new token」
4. トークンをコピー

### ステップ2: 環境変数の設定

```bash
# ~/.zshrc に追加
export FIGMA_ACCESS_TOKEN="figd_xxxxxxxxxxxxxxxxxxxxx"

# 設定を読み込み
source ~/.zshrc
```

### ステップ3: `.mcp.json`の作成

```json
{
  "mcpServers": {
    "figma": {
      "command": "npx",
      "args": ["@anthropic-ai/figma-mcp"],
      "env": {
        "FIGMA_ACCESS_TOKEN": "${FIGMA_ACCESS_TOKEN}"
      }
    },
    "context7": {
      "transport": "sse",
      "url": "https://mcp.context7.com/sse"
    },
    "playwright": {
      "command": "npx",
      "args": ["@playwright/mcp"]
    }
  }
}
```

### ステップ4: 実際の使用

#### デザインからコンポーネント生成

```
> このFigmaファイルから、Buttonコンポーネントを実装してください
> https://www.figma.com/file/xxxxx/Design-System
>
> 要件:
> - TypeScript + React
> - Tailwind CSS v4
> - バリエーション: Primary, Secondary, Outline
> - サイズ: Small, Medium, Large
```

Claude Codeの応答:
```
Figmaファイルを取得しました...

【デザイン分析】
- プライマリカラー: #2563eb
- フォント: Inter
- 角丸: 6px
- パディング: 12px 24px (Medium)

【実装】
\`\`\`typescript
// components/Button.tsx
import { cva, type VariantProps } from 'class-variance-authority';

const buttonVariants = cva(
  'inline-flex items-center justify-center rounded-md font-medium transition-colors',
  {
    variants: {
      variant: {
        primary: 'bg-blue-600 text-white hover:bg-blue-700',
        secondary: 'bg-gray-200 text-gray-900 hover:bg-gray-300',
        outline: 'border-2 border-blue-600 text-blue-600 hover:bg-blue-50',
      },
      size: {
        small: 'px-3 py-1.5 text-sm',
        medium: 'px-6 py-3 text-base',
        large: 'px-8 py-4 text-lg',
      },
    },
    defaultVariants: {
      variant: 'primary',
      size: 'medium',
    },
  }
);
\`\`\`
```

#### E2Eテストの自動生成

```
> Playwrightを使って、このButtonコンポーネントのE2Eテストを作成してください
```

## 実践例3: パフォーマンス最適化プロジェクト

### プロジェクト概要

- **フレームワーク**: Next.js
- **使用するMCP**: Chrome DevTools, Context7
- **目的**: Core Web Vitalsの改善

### セットアップ

```json
{
  "mcpServers": {
    "chrome-devtools": {
      "command": "npx",
      "args": ["chrome-devtools-mcp"]
    },
    "context7": {
      "transport": "sse",
      "url": "https://mcp.context7.com/sse"
    }
  }
}
```

### 実際の使用

```
> 本番環境のパフォーマンスを計測して、改善提案をしてください
> URL: https://example.com
```

Claude Codeの応答:
```
Chrome DevToolsで計測中...

【計測結果】
- LCP (Largest Contentful Paint): 3.2s ❌ (目標: < 2.5s)
- FID (First Input Delay): 45ms ✅ (目標: < 100ms)
- CLS (Cumulative Layout Shift): 0.15 ❌ (目標: < 0.1)

【ボトルネック】
1. メインスレッドのブロッキング時間: 1.8s
2. 大きな画像ファイル: 5MB
3. レイアウトシフト: ヘッダー画像の遅延読み込み

【改善提案】
1. 画像の最適化
   \`\`\`typescript
   import Image from 'next/image';

   <Image
     src="/hero.jpg"
     width={1920}
     height={1080}
     priority  // LCP対象画像には必須
     alt="Hero"
   />
   \`\`\`

2. フォントの最適化
   \`\`\`typescript
   import { Inter } from 'next/font/google';

   const inter = Inter({
     subsets: ['latin'],
     display: 'swap',  // CLSを防ぐ
   });
   \`\`\`

3. 動的インポートの活用
   \`\`\`typescript
   const HeavyComponent = dynamic(() => import('./HeavyComponent'), {
     ssr: false,
     loading: () => <Skeleton />,
   });
   \`\`\`
```

## 実践例4: Serenaを活用したプロジェクト理解

### プロジェクト概要

- **規模**: 大規模（100+ファイル）
- **使用するMCP**: Serena, Context7
- **目的**: プロジェクト全体の理解と一貫性の維持

### セットアップ

```bash
# miseでuvをインストール
mise use uv

# Serenaを追加
claude mcp add serena -- uvx --from git+https://github.com/oraios/serena serena start-mcp-server --enable-web-dashboard false --context ide-assistant --project $(pwd)
```

### `.mcp.json`

```json
{
  "mcpServers": {
    "serena": {
      "command": "uvx",
      "args": [
        "--from",
        "git+https://github.com/oraios/serena",
        "serena",
        "start-mcp-server",
        "--enable-web-dashboard",
        "false",
        "--context",
        "ide-assistant",
        "--project",
        "${PROJECT_ROOT}"
      ]
    },
    "context7": {
      "transport": "sse",
      "url": "https://mcp.context7.com/sse"
    }
  }
}
```

### 実際の使用

```
> Serenaを使って、このプロジェクトのアーキテクチャを分析してください
```

Claude Codeの応答:
```
Serenaからプロジェクト構造を取得しました...

【プロジェクト概要】
- ディレクトリ数: 45
- ファイル数: 312
- 主要言語: TypeScript (95%)

【アーキテクチャパターン】
- レイヤードアーキテクチャ
  - Presentation Layer: src/components/, src/pages/
  - Business Logic: src/services/
  - Data Access: src/repositories/

【発見した問題点】
1. 循環依存: src/services/UserService.ts ↔ src/services/AuthService.ts
2. 未使用ファイル: src/utils/deprecated/ (12ファイル)
3. 一貫性の欠如: 一部のコンポーネントでprops型定義が不足

【改善提案】
1. 循環依存の解消
2. 未使用ファイルの削除
3. 型定義の統一
```

## 複数MCPの連携ワークフロー

### シナリオ: 新機能の完全自動化

```
> 以下の手順で新機能を実装してください：
>
> 1. Figmaからデザインを取得
> 2. Context7で最新のReact 19ドキュメントを参照
> 3. コンポーネントを実装
> 4. PlaywrightでE2Eテストを生成
> 5. Chrome DevToolsでパフォーマンスをチェック
>
> Figma URL: https://www.figma.com/file/xxxxx/New-Feature
```

Claude Codeが自動的に:
1. Figma MCPでデザインを取得・分析
2. Context7で最新のReact 19の機能を確認
3. コンポーネントを実装（最新のベストプラクティス）
4. Playwrightでテストを自動生成
5. Chrome DevToolsでパフォーマンスを検証
6. 総合レポートを提示

## プロジェクトタイプ別のMCP組み合わせ

### Webアプリケーション

```json
{
  "mcpServers": {
    "context7": {
      "transport": "sse",
      "url": "https://mcp.context7.com/sse"
    },
    "playwright": {
      "command": "npx",
      "args": ["@playwright/mcp"]
    },
    "chrome-devtools": {
      "command": "npx",
      "args": ["chrome-devtools-mcp"]
    }
  }
}
```

### デザインシステム

```json
{
  "mcpServers": {
    "figma": {
      "command": "npx",
      "args": ["@anthropic-ai/figma-mcp"],
      "env": {
        "FIGMA_ACCESS_TOKEN": "${FIGMA_ACCESS_TOKEN}"
      }
    },
    "playwright": {
      "command": "npx",
      "args": ["@playwright/mcp"]
    },
    "context7": {
      "transport": "sse",
      "url": "https://mcp.context7.com/sse"
    }
  }
}
```

### 大規模プロジェクト

```json
{
  "mcpServers": {
    "serena": {
      "command": "uvx",
      "args": [
        "--from",
        "git+https://github.com/oraios/serena",
        "serena",
        "start-mcp-server",
        "--context",
        "ide-assistant",
        "--project",
        "${PROJECT_ROOT}"
      ]
    },
    "context7": {
      "transport": "sse",
      "url": "https://mcp.context7.com/sse"
    }
  }
}
```

## まとめ

### MCPを効果的に活用するためのポイント

1. **目的に応じたMCPサーバーの選択**
2. **適切な環境変数管理**
3. **チームでの設定共有**
4. **複数MCPの連携による自動化**

### よくある使用パターン

| シナリオ | 使用MCP | 期待効果 |
|---------|---------|---------|
| **最新情報参照** | Context7 | 常に最新のベストプラクティス |
| **デザイン実装** | Figma + Playwright | デザインの正確な実装とテスト |
| **パフォーマンス改善** | Chrome DevTools | ボトルネック特定と最適化 |
| **大規模プロジェクト** | Serena + Context7 | 一貫性の維持と効率化 |

### 次のステップ

これで第8章「MCP連携」が完了しました。次の第9章では、GitHub Actions連携について学びます。Claude Codeを@clau deメンションで呼び出し、自動的にコードレビューやタスク実行を行う方法を詳しく解説します。
