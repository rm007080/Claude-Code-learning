# 手動ファイル依頼との使い分け

## はじめに

サブエージェントと手動ファイル依頼（ドキュメントをメインセッションに読み込ませる方法）は、どちらも「指示を与える」という目的は同じですが、その仕組みと適用場面は大きく異なります。この章では、両者の違いを理解し、適切に使い分けるための判断基準を学びます。

## アテンション拡散問題

両者の違いを理解する上で、最も重要な概念が「アテンション拡散」です。

### Transformerアーキテクチャの特性

Claude Codeの基盤となるTransformerアーキテクチャは、**自己注視（Self-Attention）**メカニズムを使用しています。これは、コンテキスト内のすべてのトークンを参照して次の出力を生成する仕組みです。

**重要な特性:**
- コンテキストが大きくなるほど、アテンションが分散する
- 古い情報と新しい情報が混在すると、精度が低下する
- 関係のない情報が多いと、重要な情報を見落とす

### 手動ファイル依頼の問題

```
コンテキストサイズ: 120,000トークン
├─ 過去のコード修正履歴: 50,000トークン
├─ 現在のタスク: 20,000トークン
├─ 指示ファイル（読み込み）: 30,000トークン
└─ 新しい作業: 20,000トークン

→ アテンションが分散
→ 指示が過去のタスク情報に埋もれる
→ 精度低下
```

### サブエージェントによる解決

```
サブエージェント（独立したコンテキスト）
コンテキストサイズ: 35,000トークン
├─ サブエージェントのシステムプロンプト: 5,000トークン
├─ 指示内容（プロンプトに組み込み済み）: 10,000トークン
└─ 与えられたタスク: 20,000トークン

→ アテンションが集中
→ 指示に完全に集中できる
→ 精度向上
```

## 実行コンテキストの本質的な違い

### 手動ファイル依頼のプロセス

```
あなた: 「docs/review-guide.mdの指示に従ってレビューしてください」
    ↓
メインセッションのコンテキストに指示ファイルが読み込まれる
    ↓
コンテキスト:
├─ セッション開始からの全会話履歴
├─ 過去の実装コード
├─ 以前のレビュー結果
├─ 指示ファイルの内容 ← ここに新しく追加
└─ 新しいレビュー対象コード
    ↓
すべてが同じコンテキスト空間に蓄積
    ↓
結果: アテンション拡散により精度低下
```

### サブエージェント呼び出しのプロセス

```
あなた: 「code-reviewerサブエージェントを使用してレビューしてください」
    ↓
独立した実行環境が起動
    ↓
コンテキスト（完全に新規）:
├─ サブエージェント独自のシステムプロンプト
│   （すでに指示内容が組み込まれている）
└─ 与えられたタスク（レビュー対象コード）
    ↓
メインセッション履歴は一切見ない
    ↓
作業完了後、結果のみがメインセッションに返却
    ↓
結果: コンテキスト分離により精度向上
```

## 詳細比較表

### 基本的な違い

| 項目 | 手動ファイル依頼 | サブエージェント |
|------|----------------|-----------------|
| **コンテキスト統合** | メインセッションに統合 | 完全に分離 |
| **過去の履歴参照** | あり（すべて見える） | なし（独立） |
| **アテンション** | 分散しやすい | 集中する |
| **精度** | コンテキスト量に依存 | 安定して高い |
| **初期セットアップ** | 不要 | 必要 |
| **起動コスト** | ファイル読み込みのみ | サブエージェント起動 |

### 運用面の違い

| 項目 | 手動ファイル依頼 | サブエージェント |
|------|----------------|-----------------|
| **自動起動** | 毎回明示的な指示が必要 | 自動認識・自動委任可能 |
| **セットアップ** | シンプル | 初期セットアップ必要 |
| **再利用性** | 低い（毎プロジェクトで説明） | 高い（一度定義すれば再利用） |
| **透明性** | 高い（全過程が見える） | 中程度（結果のみ可視） |
| **デバッグ** | 容易 | Ctrl+Oで確認可能 |

### トークン効率の違い

| 項目 | 手動ファイル依頼 | サブエージェント |
|------|----------------|-----------------|
| **短期的（1-2回）** | 効率的 | やや非効率 |
| **中期的（5-10回）** | 同程度 | 同程度 |
| **長期的（20回以上）** | 効率的 | 効率的（精度が高い） |
| **複雑な指示の処理** | 混乱しやすい | 専門的・正確 |
| **大規模プロジェクト** | コンテキスト枯渇リスク | 適切 |

## 具体的な判断基準

### サブエージェントを使うべき場合

#### 1. 繰り返し実行するタスク

**例:**
- コードレビュー（毎PR実行）
- テスト実行と分析（毎実装後）
- セキュリティチェック（定期実行）

**理由:**
- 一度定義すれば、何度でも一貫した品質で実行できる
- 指示を毎回与える手間が省ける
- 長期的にトークンを節約できる

```
# サブエージェントを使う（推奨）
> code-reviewerを使ってこのPRをレビューしてください

# 手動ファイル依頼（非推奨）
> docs/review-guide.mdを読んで、その指示に従ってこのPRをレビューしてください
（これを毎PR繰り返すのは非効率）
```

#### 2. 複雑で専門的な指示が必要なタスク

**例:**
- OWASP Top 10に基づくセキュリティ監査
- TypeScript型システムの詳細なチェック
- パフォーマンスプロファイリングと最適化提案

**理由:**
- 専門的な知識を持つエージェントが、一貫して高品質な分析を提供
- コンテキスト枯渇の影響を受けない
- アテンション集中により精度向上

```
# サブエージェントを使う（推奨）
> security-auditorを使って、OWASP Top 10に基づいて脆弱性を検査してください

# 手動ファイル依頼（非推奨）
> docs/security-checklist.mdを読んで...（複雑な指示を毎回与えるのは大変）
```

#### 3. 長時間のセッションでコンテキスト枯渇が懸念される場合

**例:**
- 大規模リファクタリング
- 複数モジュールの並行開発
- 段階的な機能追加

**理由:**
- サブエージェントは独立したコンテキストを持つため、メインセッションの影響を受けない
- auto-compactが発生しても、サブエージェントの精度は維持される

```
# サブエージェントを使う（推奨）
長時間セッション中:
> quality-checkerを使って、実装した機能の品質チェックをしてください
（メインセッションがコンテキスト枯渇していても、サブエージェントは高精度を維持）
```

#### 4. チーム全体で統一された手順を共有したい場合

**例:**
- プロジェクトのコーディング規約に基づくレビュー
- 会社標準のセキュリティチェック
- デザインシステムへの準拠確認

**理由:**
- サブエージェントファイルをGitで共有できる
- 全員が同じ基準でタスクを実行できる
- 新メンバーのオンボーディングが容易

```
.claude/agents/
├── code-reviewer.md      # チーム全員で共有
├── security-auditor.md   # 会社標準
└── design-checker.md     # プロジェクト固有

# .gitignore に追加しない = チームで共有
```

### 手動ファイル依頼で十分な場合

#### 1. 1回限りのタスク

**例:**
- 特定のドキュメントの一度きりの参照
- 一時的な指示の読み込み
- 単発の調査タスク

**理由:**
- サブエージェント作成のコストが見合わない
- シンプルで迅速

```
# 手動ファイル依頼を使う（推奨）
> docs/migration-guide.mdを読んで、データベースマイグレーションの手順を教えてください

# サブエージェントを使う（過剰）
migration-expertサブエージェントを作成する（1回しか使わないので無駄）
```

#### 2. 小〜中規模プロジェクト

**例:**
- 個人プロジェクト
- 短期間のプロトタイプ開発
- 学習目的のプロジェクト

**理由:**
- コンテキスト枯渇が発生しにくい
- セットアップの手間を省ける

```
# 手動ファイル依頼を使う（推奨）
> この小規模なプロジェクトのREADME.mdを読んで、構造を理解してください
（サブエージェントを作るほどではない）
```

#### 3. シンプルな指示

**例:**
- 「このドキュメントに従ってコメントを追加」
- 「この形式でログを出力」
- 「このスタイルに合わせて整形」

**理由:**
- 複雑な専門知識が不要
- 手動指示で十分に対応可能

```
# 手動ファイル依頼を使う（推奨）
> docs/comment-style.mdを読んで、このファイルに同じスタイルでコメントを追加してください

# サブエージェントを使う（過剰）
comment-writerサブエージェントを作成する（シンプルすぎる）
```

#### 4. 完全な透明性が必要

**例:**
- デバッグ中のトラブルシューティング
- 学習目的でプロセスを理解したい
- 細かい調整を繰り返したい

**理由:**
- メインセッション内ですべての過程が見える
- リアルタイムで指示を調整できる

```
# 手動ファイル依頼を使う（推奨）
> docs/debugging-guide.mdを読んで、この問題を一緒にデバッグしましょう
（プロセスを一緒に追いたい）

# サブエージェントを使う（不適切）
debuggerサブエージェントに丸投げ（プロセスが見えない）
```

#### 5. セットアップの負担を避けたい

**例:**
- 新しい環境でクイックスタート
- サブエージェントの作り方がまだ分からない
- とにかく早く始めたい

**理由:**
- ゼロコンフィグで始められる
- 学習曲線がない

```
# 手動ファイル依頼を使う（推奨）
新しい環境で:
> とりあえずREADME.mdを読んで、プロジェクト構造を教えてください
（サブエージェント作成は後回し）
```

## 実践的な使い分けフロー

### 判断フローチャート

```
タスクを実行したい
    ↓
Q1: このタスクを今後も繰り返し実行する？
    YES → Q2へ
    NO → 【手動ファイル依頼】
    ↓
Q2: 複雑な専門知識や長い指示が必要？
    YES → Q3へ
    NO → 【手動ファイル依頼】
    ↓
Q3: コンテキスト枯渇が懸念される？（大規模プロジェクト、長時間セッション）
    YES → 【サブエージェント】
    NO → Q4へ
    ↓
Q4: チームで統一された手順を共有したい？
    YES → 【サブエージェント】
    NO → 【手動ファイル依頼】でも可、長期的には【サブエージェント】推奨
```

### 段階的移行アプローチ

多くのプロジェクトでは、段階的に手動ファイル依頼からサブエージェントに移行するのが現実的です。

**フェーズ1: 手動ファイル依頼のみ**
```
プロジェクト開始
└── すべてのタスクを手動ファイル依頼で実行
    （まずは簡単に始める）
```

**フェーズ2: 頻繁なタスクをサブエージェント化**
```
2-3週間後
├── code-reviewer.md（毎PR実行）← サブエージェント化
├── test-runner.md（毎実装後）← サブエージェント化
└── その他 ← まだ手動ファイル依頼
```

**フェーズ3: フルサブエージェント体制**
```
1-2ヶ月後
├── task-decomposer.md
├── task-executor.md
├── quality-checker.md
├── code-reviewer.md
├── test-runner.md
└── project-expert.md

すべての定型タスクをサブエージェント化
```

## 混合アプローチ

実際には、両方を併用するのが最も効果的です。

### 例: 新機能開発のワークフロー

```
1. タスク分解
   → task-decomposerサブエージェント

2. 実装
   → メインセッションで実装
   → 必要に応じて一時的なドキュメントを手動読み込み

3. 品質チェック
   → quality-checkerサブエージェント

4. コードレビュー
   → code-reviewerサブエージェント

5. ドキュメント作成
   → doc-writerサブエージェント
```

### 例: トラブルシューティング

```
1. 問題の調査
   → メインセッションで対話的に調査
   → 必要に応じてログファイルを手動読み込み

2. 原因の特定
   → debuggerサブエージェント（独立したコンテキストで分析）

3. 修正実装
   → メインセッションで実装

4. 修正後のテスト
   → test-runnerサブエージェント
```

## チェックリスト: どちらを使うべきか

### サブエージェント導入が向いている場合

- [ ] プロジェクトが大規模（複数のマイクロサービス/モジュール）
- [ ] 複数の専門領域が必要（フロントエンド、バックエンド、QA）
- [ ] 長期運用で何度も同じ指示を繰り返す
- [ ] コンテキスト枯渇の問題が発生している
- [ ] チーム全体で統一された手順を共有したい
- [ ] 高度な専門知識が必要なタスクが多い

### 手動ファイル依頼で十分な場合

- [ ] 小〜中規模プロジェクト
- [ ] 一度限りのタスク
- [ ] シンプルな指示
- [ ] 完全な透明性が必要
- [ ] セットアップの負担を避けたい
- [ ] とにかく早く始めたい

## トラブルシューティング

### 問題: サブエージェントが期待通りに動かない

**症状:**
- サブエージェントの出力が期待と異なる
- 指示が守られていない

**原因:**
- プロンプトが曖昧
- コンテキストが不足

**解決策:**
1. プロンプトをより具体的に書き直す
2. 必要なドキュメントをサブエージェントのプロンプト内で参照させる
3. Ctrl+Oでサブエージェント内部の思考プロセスを確認

### 問題: 手動ファイル依頼でコンテキスト枯渇

**症状:**
- auto-compactが頻繁に発生
- 指示が守られなくなる

**解決策:**
1. サブエージェント化を検討
2. `/compact`で会話を要約
3. 指示ファイルを簡潔にする

## まとめ

### 基本原則

| 状況 | 推奨 |
|------|------|
| **繰り返すタスク** | サブエージェント |
| **1回限りのタスク** | 手動ファイル依頼 |
| **複雑な専門知識** | サブエージェント |
| **シンプルな指示** | 手動ファイル依頼 |
| **大規模プロジェクト** | サブエージェント |
| **小規模プロジェクト** | 手動ファイル依頼 |
| **長期運用** | サブエージェント |
| **短期開発** | 手動ファイル依頼 |

### 最終的な判断

**迷ったら:**
1. まず手動ファイル依頼で始める（簡単）
2. 3回以上繰り返したら、サブエージェント化を検討
3. コンテキスト枯渇が発生したら、即座にサブエージェント化

### 次のステップ

次章（第8章）では、MCP（Model Context Protocol）連携について学びます。外部サービスとの連携により、Claude Codeの能力をさらに拡張する方法を詳しく解説します。
