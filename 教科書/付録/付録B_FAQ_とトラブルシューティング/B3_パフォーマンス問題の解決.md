# B3. パフォーマンス問題の解決

## パフォーマンス問題の分類

```
パフォーマンス問題
│
├─ 応答速度が遅い → セクションA
├─ メモリ使用量が多い → セクションB
├─ トークン消費が多い → セクションC
├─ ファイル読み込みが遅い → セクションD
└─ ネットワークが遅い → セクションE
```

---

## セクションA: 応答速度の改善

### A-1: 応答が遅い

**症状:**
- リクエスト送信後、応答まで30秒以上かかる
- コード生成に時間がかかりすぎる

**原因と解決策:**

#### 原因1: コンテキストサイズが大きすぎる

```bash
# 現在のコンテキストサイズを確認
/stats

# コンテキストをクリア
/clear-context

# 必要最小限のファイルだけを含める
/context src/specific-file.ts

# settings.jsonで除外設定
{
  "ignoreDirs": [
    "node_modules",
    "dist",
    "build",
    ".next",
    "coverage",
    ".git",
    "vendor"
  ],
  "ignorePatterns": [
    "*.log",
    "*.map",
    "*.min.js",
    "*.bundle.js",
    "*.lock"
  ],
  "maxFileSize": 1048576  // 1MB以上のファイルを除外
}
```

#### 原因2: モデル選択が適切でない

```bash
# モデルを確認
/model

# 簡単なタスクにはHaikuを使用（高速）
/model claude-3-haiku

# 複雑なタスクのみSonnetを使用
/model claude-sonnet-4

# タスクごとにモデルを使い分ける
# - 単純な質問: Haiku
# - コード生成: Sonnet
# - 複雑なリファクタリング: Opus
```

#### 原因3: ネットワーク遅延

```bash
# ネットワーク速度をテスト
ping -c 5 api.anthropic.com

# レイテンシーを確認
curl -w "@curl-format.txt" -o /dev/null -s https://api.anthropic.com

# curl-format.txt の内容
    time_namelookup:  %{time_namelookup}\n
       time_connect:  %{time_connect}\n
    time_appconnect:  %{time_appconnect}\n
   time_pretransfer:  %{time_pretransfer}\n
      time_redirect:  %{time_redirect}\n
 time_starttransfer:  %{time_starttransfer}\n
                    ----------\n
         time_total:  %{time_total}\n

# DNSキャッシュを最適化
# /etc/hosts に追加（オプション）
# IPアドレスは変更される可能性があるため、定期的に確認
```

---

### A-2: Plan modeの活用

**Plan mode を使うことで、効率的にタスクを実行:**

```bash
# Step 1: タスクを計画
/plan
"""
ユーザー認証機能を実装してください。
- JWT認証
- メール/パスワードログイン
- テスト含む
"""

# Step 2: 計画を確認
# Claude Codeが以下のような計画を生成
# 1. スキーマ設計
# 2. モデル作成
# 3. コントローラー実装
# 4. ルート設定
# 5. テスト作成

# Step 3: 一括実行
/execute

# メリット:
# - 1回のAPIコールで全体を把握
# - 効率的なトークン使用
# - 一貫性のある実装
```

---

## セクションB: メモリ使用量の最適化

### B-1: メモリ使用量が多い

**症状:**
```bash
# システムモニターでNode.jsプロセスが大量のメモリを消費
# または
FATAL ERROR: JavaScript heap out of memory
```

**解決策:**

#### 解決策1: Node.jsのメモリ上限を増やす

```bash
# メモリ上限を4GBに設定
export NODE_OPTIONS="--max-old-space-size=4096"

# 恒久的に設定
echo 'export NODE_OPTIONS="--max-old-space-size=4096"' >> ~/.bashrc
source ~/.bashrc

# メモリ上限を確認
node -e "console.log(require('v8').getHeapStatistics())"
```

#### 解決策2: キャッシュをクリア

```bash
# Claude Codeのキャッシュをクリア
rm -rf ~/.claude/cache

# セッション履歴をクリア（古いセッション）
find ~/.claude/sessions -type f -mtime +30 -delete

# ログファイルをローテーション
cd ~/.claude/logs
gzip claude-code.log
mv claude-code.log.gz "claude-code-$(date +%Y%m%d).log.gz"
> claude-code.log
```

#### 解決策3: ガベージコレクションの最適化

```bash
# ガベージコレクションを強制実行
export NODE_OPTIONS="--max-old-space-size=4096 --expose-gc"

# セッションを定期的に再起動
# 長時間使用する場合は、2-3時間ごとに再起動を推奨
```

---

### B-2: セッション管理の最適化

```bash
# 古いセッションを削除
/sessions list
/sessions delete <old-session-id>

# または一括削除
find ~/.claude/sessions -type f -mtime +7 -delete

# 自動クリーンアップスクリプト
cat > ~/.claude/cleanup.sh << 'EOF'
#!/bin/bash
# 7日以上古いセッションを削除
find ~/.claude/sessions -type f -mtime +7 -delete
# 30日以上古いログを削除
find ~/.claude/logs -type f -mtime +30 -delete
# キャッシュをクリア
rm -rf ~/.claude/cache/*
echo "Cleanup completed"
EOF

chmod +x ~/.claude/cleanup.sh

# cronで定期実行（週1回）
(crontab -l 2>/dev/null; echo "0 0 * * 0 ~/.claude/cleanup.sh") | crontab -
```

---

## セクションC: トークン消費の最適化

### C-1: トークン消費が多い

**症状:**
- APIコストが予想より高い
- すぐにレート制限に達する

**トークン消費の可視化:**

```bash
# 現在のセッションのトークン使用量
/tokens

# 統計情報
/stats

# 出力例:
# Total tokens: 15,420
# Input tokens: 12,340
# Output tokens: 3,080
# Estimated cost: $0.23
```

**最適化戦略:**

#### 戦略1: コンテキストの最小化

```bash
# ❌ 悪い例：全ファイルを含める
"""
プロジェクト全体を解析して、改善点を教えてください
"""

# ✅ 良い例：特定ファイルのみ
"""
src/services/user.service.ts を解析して、改善点を教えてください
"""

# settings.jsonで自動除外
{
  "maxFilesPerRequest": 20,
  "maxTokensPerRequest": 8192,
  "smartContextSelection": true  // AIが関連ファイルのみを選択
}
```

#### 戦略2: 段階的なアプローチ

```bash
# ❌ 一度に全て実装
"""
ユーザー管理システム全体を実装してください:
- 認証、認可、CRUD、通知、ログ、監視、テスト、ドキュメント
"""

# ✅ 段階的に実装
# Phase 1
"""
ユーザー認証（JWT）を実装してください
"""

# Phase 2
"""
ユーザーCRUD機能を追加してください
"""

# Phase 3
"""
テストを追加してください
"""
```

#### 戦略3: モデルの使い分け

```bash
# トークン単価（参考値）
# Claude Haiku:   入力 $0.25/1M  出力 $1.25/1M
# Claude Sonnet:  入力 $3.00/1M  出力 $15.00/1M
# Claude Opus:    入力 $15.00/1M 出力 $75.00/1M

# タスク別推奨モデル
/model claude-3-haiku    # 簡単な質問、リファクタリング
/model claude-sonnet-4   # コード生成、デバッグ
/model claude-3-opus     # 複雑な設計、アーキテクチャ
```

#### 戦略4: キャッシングの活用

```json
// settings.json
{
  "caching": {
    "enabled": true,
    "ttl": 3600,  // 1時間
    "maxSize": 104857600  // 100MB
  }
}
```

---

### C-2: トークン消費の監視

```bash
# 監視スクリプト
cat > ~/.claude/token-monitor.sh << 'EOF'
#!/bin/bash

LOG_FILE="$HOME/.claude/token-usage.log"
DATE=$(date '+%Y-%m-%d %H:%M:%S')

# ログからトークン使用量を抽出（実装依存）
TOKENS=$(tail -n 100 ~/.claude/logs/claude-code.log | grep -oP 'tokens: \K\d+' | tail -1)

if [ ! -z "$TOKENS" ]; then
    echo "$DATE,$TOKENS" >> $LOG_FILE
fi

# 日次レポート
if [ $(date +%H:%M) == "23:59" ]; then
    TODAY=$(date +%Y-%m-%d)
    TOTAL=$(grep "$TODAY" $LOG_FILE | awk -F, '{sum+=$2} END {print sum}')
    echo "Daily token usage: $TOTAL"
fi
EOF

chmod +x ~/.claude/token-monitor.sh

# cronで定期実行（1時間ごと）
(crontab -l 2>/dev/null; echo "0 * * * * ~/.claude/token-monitor.sh") | crontab -
```

---

## セクションD: ファイル読み込みの最適化

### D-1: ファイル読み込みが遅い

**症状:**
- 起動時に時間がかかる
- ファイル変更の検出が遅い

**解決策:**

#### 解決策1: .gitignoreと.claudeignoreの活用

```bash
# .claudeignore ファイルを作成
cat > .claudeignore << 'EOF'
# ビルド成果物
dist/
build/
.next/
out/

# 依存関係
node_modules/
vendor/
.pnp/
.pnp.js

# ログとキャッシュ
*.log
.cache/
.temp/
tmp/

# テストカバレッジ
coverage/
.nyc_output/

# IDEファイル
.vscode/
.idea/
*.swp
*.swo

# 環境変数
.env
.env.local
.env.*.local

# OS固有
.DS_Store
Thumbs.db
EOF
```

#### 解決策2: ファイルウォッチャーの最適化

```json
// settings.json
{
  "fileWatcher": {
    "enabled": true,
    "debounce": 1000,  // 1秒
    "ignore": [
      "node_modules/**",
      "dist/**",
      "*.log"
    ],
    "maxFiles": 1000
  }
}
```

#### 解決策3: 大きなファイルの除外

```json
// settings.json
{
  "maxFileSize": 1048576,  // 1MB
  "warnLargeFiles": true,
  "skipBinaryFiles": true
}
```

---

## セクションE: ネットワークの最適化

### E-1: ネットワーク遅延の改善

**診断:**

```bash
# レイテンシー測定
ping -c 10 api.anthropic.com

# トレースルート
traceroute api.anthropic.com

# DNS解決速度
dig api.anthropic.com
```

**最適化:**

#### 最適化1: DNS設定

```bash
# 高速なDNSサーバーを使用
# /etc/resolv.conf に追加
nameserver 1.1.1.1  # Cloudflare
nameserver 8.8.8.8  # Google

# macOSの場合
networksetup -setdnsservers Wi-Fi 1.1.1.1 8.8.8.8
```

#### 最適化2: HTTP/2の活用

```json
// settings.json
{
  "http": {
    "version": "2",
    "keepAlive": true,
    "keepAliveMsecs": 30000
  }
}
```

#### 最適化3: リクエストの圧縮

```json
// settings.json
{
  "compression": {
    "enabled": true,
    "level": 6  // 0-9
  }
}
```

---

## パフォーマンスモニタリング

### 包括的なモニタリングスクリプト

```bash
#!/bin/bash
# claude-performance-monitor.sh

echo "========================================="
echo "Claude Code パフォーマンスモニター"
echo "========================================="
echo ""

# 1. プロセス情報
echo "[1] プロセス情報"
ps aux | grep -i "claude-code" | grep -v grep
echo ""

# 2. メモリ使用量
echo "[2] メモリ使用量"
ps aux | grep -i "claude-code" | grep -v grep | awk '{print "RSS: " $6/1024 " MB, VSZ: " $5/1024 " MB"}'
echo ""

# 3. ディスク使用量
echo "[3] ディスク使用量"
echo "キャッシュ: $(du -sh ~/.claude/cache 2>/dev/null | cut -f1)"
echo "セッション: $(du -sh ~/.claude/sessions 2>/dev/null | cut -f1)"
echo "ログ: $(du -sh ~/.claude/logs 2>/dev/null | cut -f1)"
echo ""

# 4. ネットワーク接続
echo "[4] ネットワーク接続"
if ping -c 1 api.anthropic.com &> /dev/null; then
    LATENCY=$(ping -c 5 api.anthropic.com | tail -1 | awk -F '/' '{print $5}')
    echo "✓ 接続OK (平均レイテンシー: ${LATENCY}ms)"
else
    echo "✗ 接続エラー"
fi
echo ""

# 5. ファイルカウント
echo "[5] ファイル統計"
echo "総ファイル数: $(find . -type f 2>/dev/null | wc -l)"
echo "除外推奨ファイル数: $(find . -path ./node_modules -prune -o -path ./dist -prune -o -path ./build -prune | wc -l)"
echo ""

# 6. 最近のエラー
echo "[6] 最近のエラー (直近10件)"
if [ -f ~/.claude/logs/claude-code.log ]; then
    grep -i "error" ~/.claude/logs/claude-code.log | tail -n 10
else
    echo "ログファイルが見つかりません"
fi
echo ""

echo "========================================="
echo "モニタリング完了"
echo "========================================="
```

---

## パフォーマンスベストプラクティス

### チェックリスト

```markdown
## 起動時
- [ ] 不要なファイルを .claudeignore で除外
- [ ] node_modules, dist, build を除外設定
- [ ] 大きなバイナリファイルを除外

## 実行時
- [ ] タスクに応じたモデル選択
- [ ] コンテキストを最小限に
- [ ] Plan mode を活用
- [ ] 定期的にキャッシュクリア

## 定期メンテナンス
- [ ] 週1回：古いセッション削除
- [ ] 月1回：ログローテーション
- [ ] 月1回：依存関係の更新
- [ ] トークン使用量の確認

## ネットワーク
- [ ] 安定したインターネット接続
- [ ] DNS設定の最適化
- [ ] プロキシ設定（必要な場合）
```

---

## まとめ

パフォーマンス問題の多くは、設定の最適化で解決できます。

**優先度の高い対策:**
1. 不要なファイルの除外（最も効果的）
2. モデルの適切な選択
3. コンテキストの最小化
4. 定期的なキャッシュクリア

**定期的なメンテナンス:**
- 週1回のクリーンアップ
- 月1回のパフォーマンスチェック
- トークン使用量の監視

次章（付録C）では、継続学習のための参考リソースを紹介します。
