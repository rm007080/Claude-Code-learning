# A3. 品質向上ルール

## 完全版：AI駆動開発 品質向上ルール

このルールは、AIエージェント（Claude Code、Cursor、Codex等）に「良いコード」を書かせるための包括的なガイドラインです。CLAUDE.mdやAGENTS.mdにコピー&ペーストして使用できます。

---

## コピペ用テンプレート（完全版）

```markdown
# AI駆動開発 共通ガイドライン

## 開発の基本理念
- 動くコードを書くだけでなく、品質・保守性・安全性を常に意識する
- プロジェクトの段階（プロトタイプ、MVP、本番環境）に応じて適切なバランスを取る
- 問題を見つけたら放置せず、必ず対処または明示的に記録する
- ボーイスカウトルール：コードを見つけた時よりも良い状態で残す

## エラーハンドリングの原則
- 関連が薄く見えるエラーでも必ず解決する
- エラーの抑制（@ts-ignore、try-catch で握りつぶす等）ではなく、根本原因を修正
- 早期にエラーを検出し、明確なエラーメッセージを提供
- エラーケースも必ずテストでカバーする
- 外部APIやネットワーク通信は必ず失敗する可能性を考慮
- カスタムエラークラスを使用して、エラーの種類を明確にする
- スタックトレースを適切にログに記録する

### エラーハンドリングの実装例

#### TypeScript/JavaScript
```typescript
class AppError extends Error {
  constructor(
    public statusCode: number,
    message: string,
    public isOperational = true
  ) {
    super(message);
    Error.captureStackTrace(this, this.constructor);
  }
}

// 使用例
async function fetchUserData(userId: string) {
  try {
    const response = await api.get(`/users/${userId}`);
    return response.data;
  } catch (error) {
    if (error.response?.status === 404) {
      throw new AppError(404, `User ${userId} not found`);
    }
    if (error.response?.status === 401) {
      throw new AppError(401, 'Unauthorized access');
    }
    // 予期しないエラー
    throw new AppError(500, 'Failed to fetch user data', false);
  }
}
```

#### Python
```python
class AppError(Exception):
    def __init__(self, status_code: int, message: str, is_operational: bool = True):
        self.status_code = status_code
        self.message = message
        self.is_operational = is_operational
        super().__init__(self.message)

# 使用例
def fetch_user_data(user_id: str):
    try:
        response = requests.get(f'/users/{user_id}')
        response.raise_for_status()
        return response.json()
    except requests.exceptions.HTTPError as e:
        if e.response.status_code == 404:
            raise AppError(404, f'User {user_id} not found')
        elif e.response.status_code == 401:
            raise AppError(401, 'Unauthorized access')
        else:
            raise AppError(500, 'Failed to fetch user data', False)
```

## コード品質の基準
- DRY原則：重複を避け、単一の信頼できる情報源を維持
- SOLID原則を意識（特に単一責任の原則）
- 意味のある変数名・関数名で意図を明確に伝える
- プロジェクト全体で一貫したコーディングスタイルを維持
- 小さな問題も放置せず、発見次第修正（Broken Windows理論）
- コメントは「なぜ」を説明し、「何を」はコードで表現
- マジックナンバーを避け、定数に名前を付ける
- 関数は1つのことだけを行う（単一責任）
- ネストは3レベル以下に抑える

### コード品質の良い例・悪い例

#### ❌ 悪い例
```typescript
function p(u: any) {
  const d = new Date();
  if (u.r === 'a') {
    return u.n + ' - ' + d;
  }
  return u.n;
}
```

#### ✅ 良い例
```typescript
const ADMIN_ROLE = 'admin';

function formatUserDisplay(user: User): string {
  const currentDate = new Date();
  const isAdmin = user.role === ADMIN_ROLE;

  if (isAdmin) {
    return `${user.name} - ${currentDate.toISOString()}`;
  }

  return user.name;
}
```

## テスト規律
- テストをスキップせず、問題があれば修正する
- 実装詳細ではなく振る舞いをテスト
- AAA（Arrange-Act-Assert）パターンを使用
- テスト間の依存を避け、任意の順序で実行可能に
- テストは高速で、常に同じ結果を返すように（冪等性）
- カバレッジは指標であり、質の高いテストを重視
- 境界値、エッジケース、エラーケースを必ずテスト
- モックは最小限に、実際の依存関係を使えるなら使う

### テストの実装例

```typescript
describe('UserService', () => {
  describe('createUser', () => {
    it('should create a user with valid data', async () => {
      // Arrange
      const userData = {
        email: 'test@example.com',
        name: 'Test User',
        password: 'SecurePass123!'
      };

      // Act
      const user = await userService.createUser(userData);

      // Assert
      expect(user).toBeDefined();
      expect(user.email).toBe(userData.email);
      expect(user.name).toBe(userData.name);
      expect(user.password).not.toBe(userData.password); // パスワードはハッシュ化されている
    });

    it('should throw error when email is invalid', async () => {
      // Arrange
      const invalidUserData = {
        email: 'invalid-email',
        name: 'Test User',
        password: 'SecurePass123!'
      };

      // Act & Assert
      await expect(userService.createUser(invalidUserData))
        .rejects
        .toThrow('Invalid email format');
    });

    it('should throw error when email already exists', async () => {
      // Arrange
      const userData = {
        email: 'existing@example.com',
        name: 'Test User',
        password: 'SecurePass123!'
      };
      await userService.createUser(userData);

      // Act & Assert
      await expect(userService.createUser(userData))
        .rejects
        .toThrow('Email already exists');
    });
  });
});
```

## 保守性とリファクタリング
- 機能追加と同時に既存コードの改善を検討
- 大規模な変更は小さなステップに分割
- 使用されていないコード（デッドコード）は積極的に削除
- 依存関係は定期的に更新（セキュリティと互換性のため）
- 技術的負債は明示的にコメントやドキュメントに記録
- TODOコメントには日付と担当者を記載
- リファクタリング前後でテストを実行し、動作を確認

### 技術的負債の記録例

```typescript
/**
 * TODO: この実装は一時的なものです
 * 理由: MVP期限に間に合わせるため
 * 改善案: キャッシュ機構を実装してパフォーマンス改善
 * 期限: 2025-12-31
 * 担当: @username
 * 関連チケット: JIRA-1234
 */
function inefficientDataFetch() {
  // 現在の実装
}
```

## セキュリティの考え方
- APIキー、パスワード等は環境変数で管理（ハードコード禁止）
- すべての外部入力を検証・サニタイズ
- 必要最小限の権限で動作（最小権限の原則）
- 不要な依存関係を避ける
- セキュリティ監査ツールを定期的に実行
- SQLインジェクション対策（プリペアドステートメント使用）
- XSS対策（出力のエスケープ）
- CSRF対策（トークンベース認証）
- センシティブデータのログ出力禁止
- HTTPSの使用を強制

### セキュリティの実装例

```typescript
// ❌ 危険な例
const query = `SELECT * FROM users WHERE email = '${userInput}'`;

// ✅ 安全な例（プリペアドステートメント）
const query = 'SELECT * FROM users WHERE email = ?';
const result = await db.execute(query, [userInput]);

// ❌ 危険な例（パスワードがログに記録される）
console.log('User login:', { email, password });

// ✅ 安全な例
console.log('User login:', { email, password: '***' });

// 環境変数の使用
const API_KEY = process.env.API_KEY;
if (!API_KEY) {
  throw new Error('API_KEY environment variable is not set');
}
```

## パフォーマンスの意識
- 推測ではなく計測に基づいて最適化
- 初期段階から拡張性を考慮
- 必要になるまでリソースの読み込みを遅延（Lazy Loading）
- キャッシュの有効期限と無効化戦略を明確に
- N+1問題やオーバーフェッチを避ける
- データベースクエリを最適化（インデックス活用）
- 画像・アセットの最適化
- バンドルサイズの監視

### パフォーマンス最適化の例

```typescript
// ❌ N+1問題
async function getUsersWithPosts() {
  const users = await db.users.findMany();
  for (const user of users) {
    user.posts = await db.posts.findMany({ where: { userId: user.id } });
  }
  return users;
}

// ✅ 最適化（JOINまたはinclude使用）
async function getUsersWithPosts() {
  return await db.users.findMany({
    include: {
      posts: true
    }
  });
}

// React: useMemoでの最適化
const expensiveCalculation = useMemo(() => {
  return items.reduce((acc, item) => acc + item.price * item.quantity, 0);
}, [items]);

// React: useCallbackでの最適化
const handleClick = useCallback(() => {
  console.log('Clicked');
}, []); // 依存配列が空なので、関数は一度だけ作成される
```

## 信頼性の確保
- タイムアウト処理を適切に設定
- リトライ機構の実装（指数バックオフを考慮）
- サーキットブレーカーパターンの活用
- 一時的な障害に対する耐性を持たせる
- 適切なログとメトリクスで可観測性を確保
- ヘルスチェックエンドポイントの実装
- グレースフルシャットダウンの実装

### リトライ機構の実装例

```typescript
async function fetchWithRetry<T>(
  fn: () => Promise<T>,
  maxRetries: number = 3,
  baseDelay: number = 1000
): Promise<T> {
  let lastError: Error;

  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error as Error;

      if (attempt < maxRetries - 1) {
        // 指数バックオフ
        const delay = baseDelay * Math.pow(2, attempt);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }

  throw new Error(`Failed after ${maxRetries} attempts: ${lastError.message}`);
}

// 使用例
const data = await fetchWithRetry(() => api.get('/data'));
```

## プロジェクトコンテキストの理解
- ビジネス要件と技術要件のバランスを取る
- 現在のフェーズで本当に必要な品質レベルを判断
- 時間制約がある場合でも、最低限の品質基準を維持
- チーム全体の技術レベルに合わせた実装選択
- ステークホルダーとのコミュニケーションを重視

## トレードオフの認識
- すべてを完璧にすることは不可能（銀の弾丸は存在しない）
- 制約の中で最適なバランスを見つける
- プロトタイプなら簡潔さを、本番なら堅牢性を優先
- 妥協点とその理由を明確にドキュメント化
- 速度・品質・コストのトライアングルを意識

## Git運用の基本
- コンベンショナルコミット形式を使用
  - feat: 新機能
  - fix: バグ修正
  - docs: ドキュメント変更
  - test: テスト追加・修正
  - refactor: リファクタリング
  - style: コードスタイル変更（機能に影響なし）
  - chore: ビルドプロセスや補助ツールの変更
  - perf: パフォーマンス改善
- コミットは原子的で、単一の変更に焦点を当てる
- 明確で説明的なコミットメッセージを記述
- main/masterブランチへの直接コミットは避ける
- ブランチ名は種類/説明の形式（例: feature/user-authentication）

### コミットメッセージの例

```bash
# ✅ 良い例
feat: add user authentication with JWT
fix: resolve memory leak in data processing
docs: update API documentation for v2.0
test: add unit tests for payment service

# ❌ 悪い例
update
fixed stuff
changes
WIP
```

## コードレビューの姿勢
- レビューコメントは建設的な改善提案として受け取る
- 個人ではなくコードに焦点を当てる
- 変更の理由と影響を明確に説明
- フィードバックを学習機会として歓迎
- ニトピック（些細な指摘）と重要な指摘を区別

## デバッグのベストプラクティス
- 問題を確実に再現できる手順を確立
- 二分探索で問題の範囲を絞り込む
- 最近の変更から調査を開始
- デバッガー、プロファイラー等の適切なツールを活用
- 調査結果と解決策を記録し、知識を共有
- ラバーダックデバッギング（他人に説明する）

## 依存関係の管理
- 本当に必要な依存関係のみを追加
- package-lock.json等のロックファイルを必ずコミット
- 新しい依存関係追加前にライセンス、サイズ、メンテナンス状況を確認
- セキュリティパッチとバグ修正のため定期的に更新
- 依存関係の脆弱性スキャンを定期実行
- バンドルサイズへの影響を考慮

## ドキュメントの基準
- READMEにプロジェクトの概要、セットアップ、使用方法を明確に記載
- ドキュメントをコードと同期して更新
- 実例を示すことを優先（Show, don't tell）
- 重要な設計判断はADR (Architecture Decision Records)で記録
- APIドキュメントは自動生成を活用（OpenAPI/Swagger等）
- コード内コメントは「なぜ」に焦点を当てる

## 継続的な改善
- 学んだことを次のプロジェクトに活かす
- 定期的に振り返りを行い、プロセスを改善
- 新しいツールや手法を適切に評価して取り入れる
- チームや将来の開発者のために知識を文書化
- 失敗から学び、同じ過ちを繰り返さない
```

---

## 簡易版（初心者向け）

初心者やシンプルなプロジェクトには、以下の簡易版がおすすめです:

```markdown
# AI駆動開発 基本ルール

## 基本方針
- 動くだけでなく、読みやすいコードを書く
- エラーは適切に処理する
- テストを書く
- セキュリティを意識する

## エラーハンドリング
- try-catchで適切にエラーを捕捉
- エラーメッセージは分かりやすく
- エラーをただ無視しない

## コード品質
- 変数名は意味が分かるように
- 重複コードは避ける
- 関数は短く、1つのことだけをする
- コメントで「なぜ」を説明

## セキュリティ
- パスワードやAPIキーはコードに書かない（環境変数を使う）
- ユーザー入力は必ず検証
- SQLインジェクション対策

## Git
- コミットメッセージは明確に
- 小さな変更を頻繁にコミット
```

---

## 使い方

1. **プロジェクトの規模で選択**
   - 小規模・学習用: 簡易版
   - 中規模以上・本番環境: 完全版

2. **CLAUDE.mdに追加**
   ```bash
   # プロジェクトルートで
   nano CLAUDE.md
   # 上記ルールをコピー&ペースト
   ```

3. **Claude Codeを再起動**
   - ルールが反映される

4. **動作確認**
   - コードを生成させて、ルールに従っているか確認

---

## まとめ

品質向上ルールは、AIに「良いコード」の基準を教えるための重要なツールです。

**ポイント:**
- プロジェクトの規模と段階に応じて調整
- 完璧を目指さず、段階的に改善
- チーム全体で共有し、一貫性を保つ
- 定期的に見直し、アップデート

次は、カスタムコマンド例（A4）で実用的なコマンドを学びましょう。
