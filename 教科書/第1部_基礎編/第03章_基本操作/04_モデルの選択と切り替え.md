# モデルの選択と切り替え

## はじめに

Claude Codeでは、タスクに応じて異なるAIモデルを使い分けることができます。この章では、利用可能なモデルの特徴、使い分けのコツ、そしてコスト管理の方法を詳しく解説します。

## 利用可能なモデル

Claude Codeでは、主に2つのClaudeモデルを使用できます。

### Claude Opus 4 - 最高性能モデル

**特徴**
- Anthropicの最高性能モデル
- 複雑な推論や高度なコーディングタスクに最適
- 出力品質が最も高い
- 処理に時間がかかる場合がある
- トークンコストが高い

**得意なタスク**
- 大規模なリファクタリング
- アーキテクチャ設計
- 複雑なアルゴリズムの実装
- 難解なバグの原因調査
- 技術選定の判断
- コードレビューと最適化提案

**性能指標**
- SWE-bench: 72.7%（業界トップクラス）
- コード生成精度: 非常に高い
- 長時間タスク成功率: 90%以上

**コスト（API使用時）**
- 入力: $15 / 1M tokens
- 出力: $75 / 1M tokens

### Claude Sonnet 4.5 - バランス型モデル

**特徴**
- 品質と速度のバランスが良い
- 応答速度が速い
- コストパフォーマンスが高い
- 日常的なタスクには十分な品質

**得意なタスク**
- 通常のコード作成
- ドキュメント作成
- 簡単なバグ修正
- コードの説明
- テストコードの生成
- 定型的なタスク

**性能指標**
- コード生成精度: 高い
- 応答速度: Opusより高速
- コストパフォーマンス: 優秀

**コスト（API使用時）**
- 入力: $3 / 1M tokens（Opusの1/5）
- 出力: $15 / 1M tokens（Opusの1/5）

## モデルの選択方法

### /modelコマンドでの切り替え

**基本的な使い方**

```bash
> /model
```

**選択画面**

```
Select a model:

❯ 1. Default (Auto-select based on usage)
  2. Opus (Highest quality, slower, more expensive)
  3. Sonnet (Balanced quality and speed)
```

十字キー（↑↓）で選択し、Enterキーで決定します。

### 1. Default - 自動選択（推奨）

**動作**
- 使用量に応じて自動的にモデルを切り替え
- Pro/Maxプランの使用上限を効率的に管理

**切り替えロジック**
```
使用量 0-50%: Claude Opus 4を使用
使用量 50-100%: Claude Sonnet 4.5に自動切り替え
```

**メリット**
- 手動管理が不要
- 重要な作業ではOpusの高品質
- 上限に近づいたら自動でSonnetに切り替わる
- 使用量を最適化

**実際の使用例**

```bash
# 朝（使用量: 5%）
> ユーザー認証機能を実装してください
# → Opus で実行（高品質）

# 昼（使用量: 45%）
> テストコードを作成してください
# → まだ Opus で実行

# 夕方（使用量: 55%）
> README.mdを更新してください
# → Sonnet に自動切り替え（十分な品質）
```

**向いている人**
- 初心者
- 使用量を気にせず作業したい
- 自動最適化を任せたい

### 2. Opus - 最高品質優先

**使い方**

```bash
> /model
# 2. Opus を選択
```

**設定後**

```
Model changed to: Claude Opus 4

All future requests will use Opus until you change it.
Current usage: 35% of daily limit
```

**いつ使うか**

**ケース1: 大規模リファクタリング**

```bash
> /model  # Opus選択
> プロジェクト全体をJavaScriptからTypeScriptに移行してください
> - 型定義を適切に設定
> - 既存の動作を保持
> - 段階的に移行
```

**ケース2: アーキテクチャ設計**

```bash
> /model  # Opus選択
> マイクロサービスアーキテクチャの設計を提案してください
> - スケーラビリティを重視
> - サービス間通信の最適化
> - データ整合性の保証
```

**ケース3: 複雑なバグ調査**

```bash
> /model  # Opus選択
> メモリリークの原因を特定してください
> - プロファイリングデータを分析
> - コールスタックを追跡
> - 修正方法を提案
```

**注意点**
- 使用量の上限に早く到達する
- Proプランでは1日の制限がある
- 本当に必要なときだけ使用を推奨

### 3. Sonnet - 高速・コスト重視

**使い方**

```bash
> /model
# 3. Sonnet を選択
```

**設定後**

```
Model changed to: Claude Sonnet 4.5

All future requests will use Sonnet until you change it.
Estimated response speed: 30-50% faster than Opus
```

**いつ使うか**

**ケース1: 日常的なコーディング**

```bash
> /model  # Sonnet選択
> Reactでシンプルなボタンコンポーネントを作成してください
```

**ケース2: ドキュメント作成**

```bash
> /model  # Sonnet選択
> このAPIのドキュメントをMarkdownで作成してください
```

**ケース3: 使用量の節約**

```bash
# 使用上限に近づいている
⚠ Approaching daily limit (85% used)

> /model  # Sonnet選択
# 残りの作業を Sonnet で継続
```

**ケース4: 高速な反復開発**

```bash
> /model  # Sonnet選択
# 以下を繰り返し試行
> UIを調整してください
> もう少し大きくしてください
> 色を変更してください
# 高速な応答で効率的
```

**メリット**
- 応答が速い
- 使用量を節約できる
- 多くのタスクに十分な品質

## 実践的な使い分けパターン

### パターン1: 朝はOpus、夕方はSonnet

```bash
# 朝（使用量に余裕）
$ claude
> /model  # Opus選択
> 重要な機能を実装してください

# 夕方（使用量が増えている）
> /model  # Sonnet選択
> 軽微な修正とドキュメント作成
```

### パターン2: タスクの性質で判断

```bash
# 複雑なタスク
> /model  # Opus選択
> アーキテクチャを設計してください

# 実装が決まった後
> /model  # Sonnet選択
> 設計通りにコードを書いてください
```

### パターン3: 最初はSonnet、必要に応じてOpus

```bash
# まず Sonnet で試す
> /model  # Sonnet選択
> この問題を解決してください

# うまくいかない
> 期待通りの結果が得られません

# Opus に切り替え
> /model  # Opus選択
> もう一度、より詳細に分析してください
```

### パターン4: Defaultに任せる（最も簡単）

```bash
# 特に設定しない
> /model  # Default選択
# 自動で最適化される
```

## 使用量の確認と管理

### /statusで使用量確認

```bash
> /status
```

```
╭─────────────────────────────────────────────────────────╮
│ Session Status                                          │
├─────────────────────────────────────────────────────────┤
│ Model:          Opus (manually selected)                │
│ Daily Usage:    45% (Pro plan)                          │
│ Tokens today:   234,567 / 500,000                       │
│ Estimated:      ~2 hours until limit at current rate    │
╰─────────────────────────────────────────────────────────╯
```

**使用量の目安（Proプラン）**
- 0-30%: 余裕あり、Opus推奨
- 30-70%: Default推奨
- 70-90%: Sonnet推奨
- 90-100%: Sonnet必須

### 使用量制限に達したら

**Proプラン**

```
⚠ Daily limit reached (100%)

Switching to Sonnet automatically...
You can continue with Sonnet for the rest of the day.
```

自動的にSonnetに切り替わり、作業は継続できます。

**Maxプラン**

上限が非常に高いため、通常は制限に達しません。

**APIキー**

使用量に上限はありませんが、料金が発生します。

## コスト最適化のTips

### Tip 1: /compactを活用

```bash
# 会話が長くなったら
> /compact

# トークン数が大幅に削減され、コスト節約
Before: ~15,000 tokens
After:  ~2,500 tokens
Saved:  ~12,500 tokens
```

### Tip 2: /clearでリセット

```bash
# 不要なコンテキストは削除
> /clear

# 新しいタスクを開始
```

### Tip 3: 明確な指示でやり直しを減らす

**悪い例**
```bash
> ボタンを作って
# → 期待と違う → やり直し → トークン無駄
```

**良い例**
```bash
> 青色の送信ボタンを作成してください。
> サイズは40px高さ、Tailwind CSS使用。
# → 一発で完成 → トークン節約
```

### Tip 4: SonnetでプロトタイプClaude、Opusで仕上げ

```bash
# Step 1: Sonnet でプロトタイプ
> /model  # Sonnet
> 基本的な実装をしてください

# Step 2: 確認して、必要なら Opus で最適化
> /model  # Opus
> パフォーマンスを最適化してください
```

## モデル選択の判断フロー

```
タスクを始める
    │
    ├─ 複雑・重要・初見のタスク？
    │  YES → Opus
    │  NO  → ↓
    │
    ├─ 日常的・定型的なタスク？
    │  YES → Sonnet
    │  NO  → ↓
    │
    ├─ 判断が難しい
    │  → Default（自動選択）
    │
    └─ 使用量が多い（70%以上）？
       YES → Sonnet
       NO  → お好みで
```

## よくある質問

### Q1: Defaultで十分ですか？

**A**: はい、多くの場合Defaultで十分です。自動で最適化されるため、初心者はDefaultをおすすめします。

### Q2: Sonnetでは品質が低いですか？

**A**: いいえ、Sonnetも高品質です。日常的なタスクでは違いを感じないことも多いです。複雑なタスクでOpusの方が良い結果が出ることがあります。

### Q3: 途中でモデルを変更できますか？

**A**: はい、いつでも`/model`で変更できます。ただし、会話の途中で変更すると、若干のコンテキストの不一致が生じる可能性があります。

### Q4: Opusを使うべきタイミングは？

**A**:
- 大規模なリファクタリング
- 難解なバグの調査
- アーキテクチャ設計
- 初めての技術スタックでの実装

### Q5: APIキーの場合はどうするべき？

**A**: コストが直接課金されるため、Sonnetを基本とし、本当に必要なときだけOpusを使うことをおすすめします。

## まとめ

モデルの使い分け:

**Claude Opus 4**
- 複雑・重要なタスク
- 高品質が必要
- コストより品質重視

**Claude Sonnet 4.5**
- 日常的なタスク
- 高速な反復開発
- コスト重視

**Default（推奨）**
- 自動最適化
- 初心者向け
- 使用量を気にしない

**基本方針**
1. 初心者: Defaultのまま使う
2. 上級者: タスクに応じて切り替え
3. コスト重視: Sonnet中心、必要時のみOpus

次章では、セッションの管理方法について学びます。
